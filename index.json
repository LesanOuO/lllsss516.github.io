[{"categories":["个人网站"],"content":"安装Hugo 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe） Mac下直接使用 Homebrew 安装： brew install hugo ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:1","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录： $ cd /path/to/site 站点目录结构： ▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:2","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"创建文章 创建一个 about 页面： $ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下： +++ date = \"2015-10-25T08:36:54-07:00\" draft = true title = \"about\" +++ 正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。 $ hugo new post/first.md ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:3","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"安装皮肤 到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 Hyde 皮肤不错，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来： # 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:4","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"运行Hugo 在你的站点根目录执行 Hugo 命令进行调试： $ hugo server --theme=hyde --buildDrafts 若在config.toml设置了theme和buildDrafts： $ hugo server 浏览器里打开： http://localhost:1313 ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:5","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io（coderzh替换为你的github用户名）。 在站点根目录执行 Hugo 命令生成最终页面： $ hugo --theme=hyde --baseUrl=\"http://coderzh.github.io/\" 或者 $ hugo （注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成。） 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。 浏览器里访问：http://coderzh.github.io/ ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:6","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"其他相关 关于文章内容 它使您可以直接包含内容的元数据。Hugo支持几种不同的格式，每种格式都有自己的识别令牌。 支持的格式： TOML，以“+++”标识。 YAML，由“---”标识。 JSON，一个单独的JSON对象，由'{'和'}'包围，每行各自。 YAML Example ---title:\"spf13-vim 3.0 release and new website\"description:\"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\"tags:[\".vimrc\",\"plugins\",\"spf13-vim\",\"vim\"]lastmod:2015-12-23date:\"2012-04-06\"categories:- \"Development\"- \"VIM\"slug:\"spf13-vim-3-0-release-and-new-website\"---ContentofthefilegoesHere Required variables title The title for the content description The description for the content date The date the content will be sorted by taxonomies These will use the field name of the plural form of the index (see tags and categories above) Optional variables aliases An array of one or more aliases (e.g. old published path of a renamed content) that would be created to redirect to this content. See Aliases for details. draft If true, the content will not be rendered unless hugo is called with --buildDrafts publishdate If in the future, content will not be rendered unless hugo is called with --buildFuture type The type of the content (will be derived from the directory automatically if unset) isCJKLanguage If true, explicitly treat the content as CJKLanguage (.Summary and .WordCount can work properly in CJKLanguage) weight Used for sorting markup (Experimental) Specify \"rst\" for reStructuredText (requires rst2html) or \"md\" (default) for Markdown slug The token to appear in the tail of the URL, or url The full path to the content from the web root. If neither slug or url is present, the filename will be used. 关于配置 通常的使用情况下，一个网站并不需要一个配置文件，因为它的目录结构和模板就提供了主要的配置。 Hugo 需要在源目录查找一个 config.toml 的配置文件。如果这个文件不存在，将会查找 config.yaml，然后是 config.json 。 这个配置文件是一个整站的配置。它给 Hugo 提供了如何构建站点的方式，比如全局的参数和菜单。 配置变量 下面是 Hugo 定义好的变量列表，以及他们的默认值，你可以设置他们： --- archetypedir: \"archetype\" # hostname (and path) to the root, e.g. http://spf13.com/ baseURL: \"\" # include content marked as draft buildDrafts: false # include content with publishdate in the future buildFuture: false # enable this to make all relative URLs relative to content root. Note that this does not affect absolute URLs. relativeURLs: false canonifyURLs: false # config file (default is path/config.yaml|json|toml) config: \"config.toml\" contentdir: \"content\" dataDir: \"data\" defaultExtension: \"html\" defaultLayout: \"post\" disableLiveReload: false # Do not build RSS files disableRSS: false # Do not build Sitemap file disableSitemap: false # edit new content with this editor, if provided editor: \"\" footnoteAnchorPrefix: \"\" footnoteReturnLinkContents: \"\" # google analytics tracking id googleAnalytics: \"\" languageCode: \"\" layoutdir: \"layouts\" # Enable Logging log: false # Log File path (if set, logging enabled automatically) logFile: \"\" # \"yaml\", \"toml\", \"json\" metaDataFormat: \"toml\" newContentEditor: \"\" # Don't sync modification time of files noTimes: false paginate: 10 paginatePath: \"page\" permalinks: # Pluralize titles in lists using inflect pluralizeListTitles: true # Preserve special characters in taxonomy names (\"Gérard Depardieu\" vs \"Gerard Depardieu\") preserveTaxonomyNames: false # filesystem path to write files to publishdir: \"public\" # color-codes for highlighting derived from this style pygmentsStyle: \"monokai\" # true: use pygments-css or false: color-codes directly pygmentsUseClasses: false # default sitemap configuration map sitemap: # filesystem path to read files relative from source: \"\" staticdir: \"static\" # display memory and timing of different steps of the program stepAnalysis: false # theme to use (located in /doc/themes/THEMENAME/) theme: \"\" title: \"\" # if true, use /filename.html instead of /filename/ uglyURLs: false # Do not make the url/path to lowercase disablePathToLower: false # if true, auto-detect Chinese/Japanese/Korean Languages in the content. (.Summary and .WordCount can work properly in CJKLanguage) hasCJKLanguage false # verbose output verbose: false # verbose logging verboseLog: false # watch filesystem for chan","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:7","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"GitHub Pages GitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub加Vercel。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:1","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第一步：注册登录Vercel 我想大家应该都有GitHub账号吧，这里就不多说了。 点击Vercel官网,并使用GitHub登录。 注意⚠️：GitHub账号不要使用QQ邮箱作为主邮箱。如果已经用QQ邮箱注册了GitHub，可以到Setting -\u003e Emails里修改自己的主邮箱。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:2","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第二步：导入仓库 它会让你选择一种登录Vercel的方法，支持使用GitHub，GitLab和Bitbucket登录，这里我们选GitHub，后面就是无脑Next的步骤。 顺利的话稍等片刻就会弹出部署成功的页面，还有浮夸的撒花。 部署完成之后可以点击visit进入网页看看效果。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:3","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第三步：配置域名 1.点击view Domains进行绑定自己的域名或者点击Settings👉Domains👉输入自己的域名 2.输入自己的域名，然后点Add，它会弹出来一些需要做的配置，接下来需要去我们的域名提供商那里根据Vercel给出的要求进行配置。需要修改的有：Name Servers以及域名解析 最后等待等这两个改动都生效之后就可以用我们自己的域名访问刚刚建立的网站啦~ 以后想要修改网站的话，只需要将改动push到GitHub上，vercel会自动把改动同步过来，完全不用管，超省心。 在一级域名配置好之后，也可以直接在vercel中使用二级域名，无需进行额外设置。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:4","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["学习笔记"],"content":"一、引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.thymeleaf.extras\u003c/groupId\u003e \u003cartifactId\u003ethymeleaf-extras-springsecurity4\u003c/artifactId\u003e \u003cversion\u003e3.0.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:1","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"二、配置WebSecurityConfigurerAdapter 使用内存用户储存且认证 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests()//表示下面是认证的配置 .antMatchers(\"/login\").permitAll() .antMatchers(\"/login/form\").permitAll() .antMatchers(\"/css/**\").permitAll() .antMatchers(\"/js/**\").permitAll() .anyRequest()//任何请求 .authenticated();//都需要身份认证 http.formLogin()//表单认证 .loginPage(\"/login\")//使用本人制作的登录界面 .usernameParameter(\"user\")//username更改 .loginProcessingUrl(\"/login/form\")//表单提交的api .defaultSuccessUrl(\"/\")//登录成功跳转页面 .failureUrl(\"/login/error\").permitAll();//登录错误跳转界面 http.logout().logoutSuccessUrl(\"/login\");//登出 http.csrf().disable();//防止跨站攻击 } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication()//使用内存用户储存 //配置了一个user用户和一个admin用户 .withUser(\"user\").password(\"password\").roles(\"USER\").and() .withUser(\"admin\").password(\"password\").roles(\"USER\", \"ADMIN\"); } } ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:2","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"三、由数据库认证登录 在MySQL中创建用户表 CREATE TABLE `admin` ( `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `id` int(11) NOT NULL AUTO_INCREMENT, `role` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO `admin` VALUES ('admin', '123', 1, 'admin'); entity层创建实体 @Data //使用lombok,简化get,set public class UserInfo { private Integer id; private String username; private String password; private String role; } dao层创建数据存取对象 @Mapper//mapper.xml分离 @Repository public interface UserInfoDao { UserInfo getUserInfoByUsername(String username); } 创建dao对应的mapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"cn.llssit.ls.dao.UserInfoDao\"\u003e \u003cselect id=\"getUserInfoByUsername\" resultType=\"UserInfo\"\u003e select * from admin where username = #{username} \u003c/select\u003e \u003c/mapper\u003e service层 interface public interface UserInfoSevice { UserInfo getUserInfoByUsername(String username); } impl @Service public class UserInfoServiceImpl implements UserInfoSevice { @Autowired private UserInfoDao userInfoDao; @Override public UserInfo getUserInfoByUsername(String username) { return userInfoDao.getUserInfoByUsername(username); } } controller层或者其他运用 springsecurity数据库认证 首先需要重写接口loadUserByUsername @Component public class MyUserDetailService implements UserDetailsService { @Autowired private UserInfoSevice userInfoService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { // 通过用户名从数据库获取用户信息 UserInfo userInfo = userInfoService.getUserInfoByUsername(s); if (userInfo == null) { throw new UsernameNotFoundException(\"用户不存在\"); } // 得到用户角色 String role = userInfo.getRole(); // 角色集合 List\u003cGrantedAuthority\u003e authorities = new ArrayList\u003c\u003e(); // 角色必须以`ROLE_`开头，数据库中没有，则在这里加 authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role)); return new User( userInfo.getUsername(), // 因为数据库是明文，所以这里需加密密码 new BCryptPasswordEncoder().encode(userInfo.getPassword()), authorities ); } } 然后创建Security的配置类WebSecurityConfig继承WebSecurityConfigurerAdapter，并重写configure(auth)方法 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private MyUserDetailService userDatailService; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/login\").permitAll() .antMatchers(\"/login/form\").permitAll() .antMatchers(\"/css/**\").permitAll() .antMatchers(\"/js/**\").permitAll() .anyRequest() .authenticated(); http.formLogin() .loginPage(\"/login\") .usernameParameter(\"user\") .loginProcessingUrl(\"/login/form\") .defaultSuccessUrl(\"/\") .failureUrl(\"/login/error\").permitAll(); http.logout().logoutSuccessUrl(\"/login\"); http.csrf().disable(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth // 从数据库读取的用户进行身份认证 .userDetailsService(userDatailService) .passwordEncoder(new BCryptPasswordEncoder()); } } 角色访问 @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 修改Controller.java类，增加方法的访问权限@PreAuthorize(\"hasAnyRole('admin')\") ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:3","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"Java集合框架 导入包 import java.util.*; ArrayList 一、定义一个ArrayList //默认创建一个ArrayList集合 List\u003cString\u003e list = new ArrayList\u003c\u003e(); //创建一个初始化长度为100的ArrayList集合 List\u003cString\u003e initlist = new ArrayList\u003c\u003e(100); //将其他类型的集合转为ArrayList List\u003cString\u003e setList = new ArrayList\u003c\u003e(new HashSet()); 二、ArrayList常用方法 add(E element) set(int index, E element) 因为ArrayList底层是由数组实现的，set实现非常简单，调用 set(4, \"4\") 通过传入的数字下标找到对应的位置，替换其中的元素，前提也需要首先判断传入的数组下标是否越界。 get(int index) remove(int index) remove(Object o) 其他方法 size() : 获取集合长度，通过定义在ArrayList中的私有变量size得到 isEmpty()：是否为空，通过定义在ArrayList中的私有变量size得到 contains(Object o)：是否包含某个元素，通过遍历底层数组elementData，通过equals或==进行判断 clear()：集合清空，通过遍历底层数组elementData，设置为null ArrayList的遍历 List\u003cString\u003e list=new ArrayList\u003cString\u003e(); list.add(\"Hello\"); list.add(\"World\"); list.add(\"HAHAHAHA\"); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) { //也可以改写 for(int i=0;i\u003clist.size();i++) 这种形式 System.out.println(str); } //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i\u003cstrArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 { System.out.println(strArray[i]); } //第三种遍历 使用迭代器进行相关遍历 Iterator\u003cString\u003e ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 { System.out.println(ite.next()); } HashMap 一、定义一个HashMap Map\u003cString, String\u003e map = new HashMap\u003c\u003e(); 二、HashMap常用方法 public V put(K key, V value) :插入键值对数据 public V get(Object key) :根据键值获取键值对值数据 public int size() :获取Map中键值对的个数 public boolean containsKey(Object key) :判断Map集合中是否包含键为key的键值对 boolean containsValue(Object value) :判断Map集合中是否包含值为value的键值对 public boolean isEmpty() :判断Map集合中是否没有任何键值对 public V remove(Object key) :根据键值删除Map中键值对 public void clear() :清空Map集合中所有的键值对 HashMap的遍历 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); //第一种：普遍使用，二次取值 System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) { System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); } //第二种 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator\u003cMap.Entry\u003cString, String\u003e\u003e it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry\u003cString, String\u003e entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry\u003cString, String\u003e entry : map.entrySet()) { System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第四种 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) { System.out.println(\"value= \" + v); } ","date":"2020-10-12","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"Java多线程 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 一个线程的生命周期 线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态： 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态： 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态： 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态： 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态： 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 Thread 方法 序号 方法描述 1 **public void start()**使该线程开始执行；==Java== 虚拟机调用该线程的 run 方法。 2 **public void run()**如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 **public final void setName(String name)**改变线程名称，使之与参数 name 相同。 4 **public final void setPriority(int priority)** 更改线程的优先级。 5 **public final void setDaemon(boolean on)**将该线程标记为守护线程或用户线程。 6 **public final void join(long millisec)**等待该线程终止的时间最长为 millis 毫秒。 7 **public void interrupt()**中断线程。 8 **public final boolean isAlive()**测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 **public static void yield()**暂停当前正在执行的线程对象，并执行其他线程。 2 **public static void sleep(long millisec)**在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 **public static boolean holdsLock(Object x)**当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 **public static Thread currentThread()**返回对当前正在执行的线程对象的引用。 5 **public static void dumpStack()**将当前线程的堆栈跟踪打印至标准错误流。 创建一个线程 Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现Runnable 接口来创建线程 创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： public void run() 你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是我们经常使用的： Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 void start(); 下面是一个创建线程并开始让它执行的实例： class RunnableDemo implements Runnable { private Thread t; private String threadName; RunnableDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i \u003e 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } } } public class TestThread { public static void main(String args[]) { RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); } } 通过继承Thread来创建线程 创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 class ThreadDemo extends Thread { private Thread t; private String threadName; ThreadDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i \u003e 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + ","date":"2020-10-12","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"一、写前准备 在atom文本编译器中自带着markdown的编写与浏览功能。 浏览使用快捷键ctl+shift+m就可以打开markdown预览。 简书中在设置-\u003e默认编辑器-\u003emarkdown编译，就可以设置markdown。 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:1:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"二、标题 在想要设置为标题的文字前面加#来表示标题 一个#号是以及标题，两个#是二级标题，最多有六级标题 标准语法需要在#后加空格才能表示 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:2:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"三、字体 加粗 在要加粗的文字左右分别用两个*标注 斜体 在要倾斜的文字左右分别用一个*标注 斜体加粗 在要倾斜和加粗的文字左右分别用三个*标注 删除线 在要加删除线的文字左右分别用两个～标注 例如： **加粗字体** *斜体字体* ***斜体加粗字体*** ~~删除字体~~ 效果： 加粗字体，斜体字体，斜体加粗字体，删除字体 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:3:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"四、引用 在引用文字前加\u003e。引用可以嵌套，如一个\u003e、两个\u003e等等 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:4:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"五、\u0008分割线 三个或三个以上的-或者*\u0008\u0008 例： --- *** \u0008效果: ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:5:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"六、\u0008图片 使用方法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:6:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"七、超链接 使用方法： [超链接名](超链接地址 \"超链接title\") title可加可不加 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 \u003ca href=\"超链接地址\" target=\"_blank\"\u003e超链接名\u003c/a\u003e 示例 \u003ca href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\"\u003e简书\u003c/a\u003e ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:7:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"八、列表 无序列表 使用方法：无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表 使用方法：数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 列表嵌套 使用方法：上一级和下一级之间敲三个空格 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:8:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"九、表格 使用方法： |表头|表头|表头| |-|:-:|-:| |内容|内容|内容| |内容|内容|内容| 第二行分割表头和内容。 -有一个就行 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:9:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十、代码 使用方法： 单行代码：代码之间分别用一个反引号包起来 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 代码\u0008高亮：在第一行反引号后面输入代码块所使用的语言 代码高亮演示： `c #include \"stdio.h\" int main(){ printf(\"hello world\\n\"); return 0; } ` #include \"stdio.h\" int main(){ printf(\"hello world\\n\"); return 0; } ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:10:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十一、流程图 使用方法： st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:11:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十二、数学表达式 用反引号将数学表达式封装,并在第三个号后标注math代表数学公式. E = mc^2 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:12:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十三、待办事项 在待办的事项文本或者清单文本前加上- 、- [x]即可 - [ ] 表示未完成，- [x] 表示已完成。 注：键入字符与字符之间都要保留一个字符的空格。 \u0008效果 分析需求 研发 测试 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:13:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"结语 Markdown换行方法： 在本行最后\u0008敲两个空格即可 每行间空一行即可 Mac上反引号方法： 在英文状态下按住option键+数字\u00081左边的键 本文章为个人学习笔记，转载了多人的博客，如有雷同请见谅。 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:14:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"}]