[{"categories":["学习笔记"],"content":"API Collection 接口的接口 对象的集合（单列集合） ├——-List 接口：元素按进入先后有序保存，可重复 │—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全 │—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全 │—————-└ Vector 接口实现类 数组， 同步， 线程安全 │ ———————-└ Stack 是Vector类的实现类 └——-Set 接口： 仅接收一次，不可重复，并做内部排序 ├—————-└HashSet 使用hash表（数组）存储元素 │————————└ LinkedHashSet 链表维护元素的插入次序 └ —————-TreeSet 底层实现为二叉树，元素排好序 Map 接口 键值对的集合 （双列集合） ├———Hashtable 接口实现类， 同步， 线程安全 ├———HashMap 接口实现类 ，没有同步， 线程不安全- │—————–├ LinkedHashMap 双向链表和哈希表实现 │—————–└ WeakHashMap ├ ——–TreeMap 红黑树对所有的key进行排序 └———IdentifyHashMap ","date":"2021-01-13","objectID":"/java%E9%9B%86%E5%90%88/:0:0","tags":["Java"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["学习笔记"],"content":"HashSet HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。 HashSet 实现了 Set 接口。 HashSet 类位于 java.util 包中，使用前需要引入它，语法格式如下： import java.util.HashSet; // 引入 HashSet 类 以下实例我们创建一个 HashSet 对象 sites，用于保存字符串元素： HashSet\u003cString\u003e sites = new HashSet\u003cString\u003e(); 部分方法： HashSet\u003cString\u003e sites = new HashSet\u003cString\u003e(); sites.add(\"Google\"); sites.contains(\"Taobao\"); sites.remove(\"Taobao\"); sites.clear(); for (String i : sites) { System.out.println(i); } ","date":"2021-01-13","objectID":"/java%E9%9B%86%E5%90%88/:0:1","tags":["Java"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["学习笔记"],"content":"HashMap HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。 HashMap 是无序的，即不会记录插入的顺序。 HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 HashMap 类位于 java.util 包中，使用前需要引入它，语法格式如下： import java.util.HashMap; // 引入 HashMap 类 以下实例我们创建一个 HashMap 对象 Sites， 整型（Integer）的 key 和字符串（String）类型的 value： HashMap\u003cInteger, String\u003e Sites = new HashMap\u003cInteger, String\u003e(); 部分方法： // 创建 HashMap 对象 Sites HashMap\u003cInteger, String\u003e Sites = new HashMap\u003cInteger, String\u003e(); // 添加键值对 Sites.put(1, \"Google\"); Sites.get(3); Sites.remove(4); // 输出 key 和 value for (Integer i : Sites.keySet()) { System.out.println(\"key: \" + i + \" value: \" + Sites.get(i)); } // 返回所有 value 值 for(String value: Sites.values()) { // 输出每一个value System.out.print(value + \", \"); } Java HashMap 常用方法列表如下： 方法 描述 clear() 删除 hashMap 中的所有键/值对 clone() 复制一份 hashMap isEmpty() 判断 hashMap 是否为空 size() 计算 hashMap 中键/值对的数量 put() 将键/值对添加到 hashMap 中 putAll() 将所有键/值对添加到 hashMap 中 putIfAbsent() 如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。 remove() 删除 hashMap 中指定键 key 的映射关系 containsKey() 检查 hashMap 中是否存在指定的 key 对应的映射关系。 containsValue() 检查 hashMap 中是否存在指定的 value 对应的映射关系。 replace() 替换 hashMap 中是指定的 key 对应的 value。 replaceAll() 将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。 get() 获取指定 key 对应对 value getOrDefault() 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 forEach() 对 hashMap 中的每个映射执行指定的操作。 entrySet() 返回 hashMap 中所有映射项的集合集合视图。 keySet() 返回 hashMap 中所有 key 组成的集合视图。 values() 返回 hashMap 中存在的所有 value 值。 merge() 添加键值对到 hashMap 中 compute() 对 hashMap 中指定 key 的值进行重新计算 computeIfAbsent() 对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中 computeIfPresent() 对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。 ","date":"2021-01-13","objectID":"/java%E9%9B%86%E5%90%88/:0:2","tags":["Java"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["学习笔记"],"content":"API ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Vector Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的： Vector 是同步访问的。 Vector 包含了许多传统的方法，这些方法不属于集合框架。 Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 Vector 类支持 4 种构造方法。 第一种构造方法创建一个默认的向量，默认大小为 10： Vector() 第二种构造方法创建指定大小的向量。 Vector(int size) 第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。 Vector(int size,int incr) 第四种构造方法创建一个包含集合 c 元素的向量： Vector(Collection c) 序号 方法描述 1 void add(int index, Object element) 在此向量的指定位置插入指定的元素。 2 boolean add(Object o) 将指定元素添加到此向量的末尾。 3 void clear() 从此向量中移除所有元素。 4 boolean contains(Object elem) 如果此向量包含指定的元素，则返回 true。 5 Object get(int index) 返回向量中指定位置的元素。 6 int indexOf(Object elem) 返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。 7 boolean isEmpty() 测试此向量是否不包含组件。 8 int size() 返回此向量中的组件数。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:1","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。 堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。 Stack() 除了由Vector定义的所有方法，自己也定义了一些方法： 序号 方法描述 1 boolean empty() 测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:2","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"ArrayList ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。 ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下： import java.util.ArrayList; // 引入 ArrayList 类 ArrayList\u003cE\u003e objectName =new ArrayList\u003c\u003e();　// 初始化 E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。 objectName: 对象名。 ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 Java ArrayList 常用方法列表如下： 方法 描述 add() 将元素插入到指定位置的 arraylist 中 addAll() 添加集合中的所有元素到 arraylist 中 clear() 删除 arraylist 中的所有元素 clone() 复制一份 arraylist contains() 判断元素是否在 arraylist get() 通过索引值获取 arraylist 中的元素 indexOf() 返回 arraylist 中元素的索引值 removeAll() 删除存在于指定集合中的 arraylist 里的所有元素 remove() 删除 arraylist 里的单个元素 size() 返回 arraylist 里元素数量 isEmpty() 判断 arraylist 是否为空 subList() 截取部分 arraylist 的元素 set() 替换 arraylist 中指定索引的元素 sort() 对 arraylist 元素进行排序 toArray() 将 arraylist 转换为数组 toString() 将 arraylist 转换为字符串 ensureCapacity() 设置指定容量大小的 arraylist lastIndexOf() 返回指定元素在 arraylist 中最后一次出现的位置 retainAll() 保留 arraylist 中在指定集合中也存在的那些元素 containsAll() 查看 arraylist 是否包含指定集合中的所有元素 trimToSize() 将 arraylist 中的容量调整为数组中的元素个数 removeRange() 删除 arraylist 中指定索引之间存在的元素 replaceAll() 将给定的操作内容替换掉数组中每一个元素 removeIf() 删除所有满足特定条件的 arraylist 元素 forEach() 遍历 arraylist 中每一个元素并执行特定操作 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:3","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"LinkedList 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。 链表可分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。 与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。 以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 LinkedList 继承了 AbstractSequentialList 类。 LinkedList 实现了 Queue 接口，可作为队列使用。 LinkedList 实现了 List 接口，可进行列表的相关操作。 LinkedList 实现了 Deque 接口，可作为队列使用。 LinkedList 实现了 Cloneable 接口，可实现克隆。 LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:4","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Queue Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构 Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。 ​ add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 remove、element、offer 、poll、peek 其实是属于Queue接口。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:5","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Comparator自定义排序 Comparator接口可以实现自定义排序，实现Comparator接口时，要重写compare方法： int compare(Object o1, Object o2) 返回一个基本类型的整型 如果要按照升序排序,则o1 小于o2，返回-1（负数），相等返回0，01大于02返回1（正数） 如果要按照降序排序,则o1 小于o2，返回1（正数），相等返回0，01大于02返回-1（负数） list.sort(new Comparator\u003cPerson\u003e() { int flag=0; @Override public int compare(Person o1, Person o2) { int a=o1.getSex().compareTo(o2.getSex()); if(a!=0\u0026\u0026a\u003e0){ return -1; } else if(o1.getSex().equals(o2.getSex())){ if(o1.getAge()\u003co2.getAge()){ return -1; } else if(o1.getAge()==o2.getAge()){ if(o1.getWeigth()\u003co2.getWeigth()){ return -1; } else if(o1.getWeigth()==o2.getWeigth()){ if(o1.getHeight()\u003eo2.getHeight()){ return -1; } else if(o1.getHeight()==o2.getHeight()){ if(o1.getName().length()\u003co2.getName().length()){ return -1; } } } } } return 1; } }); ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:6","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["个人网站"],"content":"安装Hugo 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe） Mac下直接使用 Homebrew 安装： brew install hugo ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:1","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录： $ cd /path/to/site 站点目录结构： ▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:2","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"创建文章 创建一个 about 页面： $ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下： +++ date = \"2015-10-25T08:36:54-07:00\" draft = true title = \"about\" +++ 正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。 $ hugo new post/first.md ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:3","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"安装皮肤 到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 Hyde 皮肤不错，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来： # 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:4","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"运行Hugo 在你的站点根目录执行 Hugo 命令进行调试： $ hugo server --theme=hyde --buildDrafts 若在config.toml设置了theme和buildDrafts： $ hugo server 浏览器里打开： http://localhost:1313 ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:5","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io（coderzh替换为你的github用户名）。 在站点根目录执行 Hugo 命令生成最终页面： $ hugo --theme=hyde --baseUrl=\"http://coderzh.github.io/\" 或者 $ hugo （注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成。） 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。 浏览器里访问：http://coderzh.github.io/ ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:6","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"其他相关 关于文章内容 它使您可以直接包含内容的元数据。Hugo支持几种不同的格式，每种格式都有自己的识别令牌。 支持的格式： TOML，以“+++”标识。 YAML，由“---”标识。 JSON，一个单独的JSON对象，由'{'和'}'包围，每行各自。 YAML Example ---title:\"spf13-vim 3.0 release and new website\"description:\"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\"tags:[\".vimrc\",\"plugins\",\"spf13-vim\",\"vim\"]lastmod:2015-12-23date:\"2012-04-06\"categories:- \"Development\"- \"VIM\"slug:\"spf13-vim-3-0-release-and-new-website\"---ContentofthefilegoesHere Required variables title The title for the content description The description for the content date The date the content will be sorted by taxonomies These will use the field name of the plural form of the index (see tags and categories above) Optional variables aliases An array of one or more aliases (e.g. old published path of a renamed content) that would be created to redirect to this content. See Aliases for details. draft If true, the content will not be rendered unless hugo is called with --buildDrafts publishdate If in the future, content will not be rendered unless hugo is called with --buildFuture type The type of the content (will be derived from the directory automatically if unset) isCJKLanguage If true, explicitly treat the content as CJKLanguage (.Summary and .WordCount can work properly in CJKLanguage) weight Used for sorting markup (Experimental) Specify \"rst\" for reStructuredText (requires rst2html) or \"md\" (default) for Markdown slug The token to appear in the tail of the URL, or url The full path to the content from the web root. If neither slug or url is present, the filename will be used. 关于配置 通常的使用情况下，一个网站并不需要一个配置文件，因为它的目录结构和模板就提供了主要的配置。 Hugo 需要在源目录查找一个 config.toml 的配置文件。如果这个文件不存在，将会查找 config.yaml，然后是 config.json 。 这个配置文件是一个整站的配置。它给 Hugo 提供了如何构建站点的方式，比如全局的参数和菜单。 配置变量 下面是 Hugo 定义好的变量列表，以及他们的默认值，你可以设置他们： --- archetypedir: \"archetype\" # hostname (and path) to the root, e.g. http://spf13.com/ baseURL: \"\" # include content marked as draft buildDrafts: false # include content with publishdate in the future buildFuture: false # enable this to make all relative URLs relative to content root. Note that this does not affect absolute URLs. relativeURLs: false canonifyURLs: false # config file (default is path/config.yaml|json|toml) config: \"config.toml\" contentdir: \"content\" dataDir: \"data\" defaultExtension: \"html\" defaultLayout: \"post\" disableLiveReload: false # Do not build RSS files disableRSS: false # Do not build Sitemap file disableSitemap: false # edit new content with this editor, if provided editor: \"\" footnoteAnchorPrefix: \"\" footnoteReturnLinkContents: \"\" # google analytics tracking id googleAnalytics: \"\" languageCode: \"\" layoutdir: \"layouts\" # Enable Logging log: false # Log File path (if set, logging enabled automatically) logFile: \"\" # \"yaml\", \"toml\", \"json\" metaDataFormat: \"toml\" newContentEditor: \"\" # Don't sync modification time of files noTimes: false paginate: 10 paginatePath: \"page\" permalinks: # Pluralize titles in lists using inflect pluralizeListTitles: true # Preserve special characters in taxonomy names (\"Gérard Depardieu\" vs \"Gerard Depardieu\") preserveTaxonomyNames: false # filesystem path to write files to publishdir: \"public\" # color-codes for highlighting derived from this style pygmentsStyle: \"monokai\" # true: use pygments-css or false: color-codes directly pygmentsUseClasses: false # default sitemap configuration map sitemap: # filesystem path to read files relative from source: \"\" staticdir: \"static\" # display memory and timing of different steps of the program stepAnalysis: false # theme to use (located in /doc/themes/THEMENAME/) theme: \"\" title: \"\" # if true, use /filename.html instead of /filename/ uglyURLs: false # Do not make the url/path to lowercase disablePathToLower: false # if true, auto-detect Chinese/Japanese/Korean Languages in the content. (.Summary and .WordCount can work properly in CJKLanguage) hasCJKLanguage false # verbose output verbose: false # verbose logging verboseLog: false # watch filesystem for chan","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:7","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"GitHub Pages GitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub加Vercel。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:1","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第一步：注册登录Vercel 我想大家应该都有GitHub账号吧，这里就不多说了。 点击Vercel官网,并使用GitHub登录。 注意⚠️：GitHub账号不要使用QQ邮箱作为主邮箱。如果已经用QQ邮箱注册了GitHub，可以到Setting -\u003e Emails里修改自己的主邮箱。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:2","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第二步：导入仓库 它会让你选择一种登录Vercel的方法，支持使用GitHub，GitLab和Bitbucket登录，这里我们选GitHub，后面就是无脑Next的步骤。 顺利的话稍等片刻就会弹出部署成功的页面，还有浮夸的撒花。 部署完成之后可以点击visit进入网页看看效果。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:3","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第三步：配置域名 1.点击view Domains进行绑定自己的域名或者点击Settings👉Domains👉输入自己的域名 2.输入自己的域名，然后点Add，它会弹出来一些需要做的配置，接下来需要去我们的域名提供商那里根据Vercel给出的要求进行配置。需要修改的有：Name Servers以及域名解析 最后等待等这两个改动都生效之后就可以用我们自己的域名访问刚刚建立的网站啦~ 以后想要修改网站的话，只需要将改动push到GitHub上，vercel会自动把改动同步过来，完全不用管，超省心。 在一级域名配置好之后，也可以直接在vercel中使用二级域名，无需进行额外设置。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:4","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["学习笔记"],"content":"一、引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.thymeleaf.extras\u003c/groupId\u003e \u003cartifactId\u003ethymeleaf-extras-springsecurity4\u003c/artifactId\u003e \u003cversion\u003e3.0.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:1","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"二、配置WebSecurityConfigurerAdapter 使用内存用户储存且认证 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests()//表示下面是认证的配置 .antMatchers(\"/login\").permitAll() .antMatchers(\"/login/form\").permitAll() .antMatchers(\"/css/**\").permitAll() .antMatchers(\"/js/**\").permitAll() .anyRequest()//任何请求 .authenticated();//都需要身份认证 http.formLogin()//表单认证 .loginPage(\"/login\")//使用本人制作的登录界面 .usernameParameter(\"user\")//username更改 .loginProcessingUrl(\"/login/form\")//表单提交的api .defaultSuccessUrl(\"/\")//登录成功跳转页面 .failureUrl(\"/login/error\").permitAll();//登录错误跳转界面 http.logout().logoutSuccessUrl(\"/login\");//登出 http.csrf().disable();//防止跨站攻击 } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication()//使用内存用户储存 //配置了一个user用户和一个admin用户 .withUser(\"user\").password(\"password\").roles(\"USER\").and() .withUser(\"admin\").password(\"password\").roles(\"USER\", \"ADMIN\"); } } ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:2","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"三、由数据库认证登录 在MySQL中创建用户表 CREATE TABLE `admin` ( `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `id` int(11) NOT NULL AUTO_INCREMENT, `role` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO `admin` VALUES ('admin', '123', 1, 'admin'); entity层创建实体 @Data //使用lombok,简化get,set public class UserInfo { private Integer id; private String username; private String password; private String role; } dao层创建数据存取对象 @Mapper//mapper.xml分离 @Repository public interface UserInfoDao { UserInfo getUserInfoByUsername(String username); } 创建dao对应的mapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"cn.llssit.ls.dao.UserInfoDao\"\u003e \u003cselect id=\"getUserInfoByUsername\" resultType=\"UserInfo\"\u003e select * from admin where username = #{username} \u003c/select\u003e \u003c/mapper\u003e service层 interface public interface UserInfoSevice { UserInfo getUserInfoByUsername(String username); } impl @Service public class UserInfoServiceImpl implements UserInfoSevice { @Autowired private UserInfoDao userInfoDao; @Override public UserInfo getUserInfoByUsername(String username) { return userInfoDao.getUserInfoByUsername(username); } } controller层或者其他运用 springsecurity数据库认证 首先需要重写接口loadUserByUsername @Component public class MyUserDetailService implements UserDetailsService { @Autowired private UserInfoSevice userInfoService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { // 通过用户名从数据库获取用户信息 UserInfo userInfo = userInfoService.getUserInfoByUsername(s); if (userInfo == null) { throw new UsernameNotFoundException(\"用户不存在\"); } // 得到用户角色 String role = userInfo.getRole(); // 角色集合 List\u003cGrantedAuthority\u003e authorities = new ArrayList\u003c\u003e(); // 角色必须以`ROLE_`开头，数据库中没有，则在这里加 authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role)); return new User( userInfo.getUsername(), // 因为数据库是明文，所以这里需加密密码 new BCryptPasswordEncoder().encode(userInfo.getPassword()), authorities ); } } 然后创建Security的配置类WebSecurityConfig继承WebSecurityConfigurerAdapter，并重写configure(auth)方法 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private MyUserDetailService userDatailService; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/login\").permitAll() .antMatchers(\"/login/form\").permitAll() .antMatchers(\"/css/**\").permitAll() .antMatchers(\"/js/**\").permitAll() .anyRequest() .authenticated(); http.formLogin() .loginPage(\"/login\") .usernameParameter(\"user\") .loginProcessingUrl(\"/login/form\") .defaultSuccessUrl(\"/\") .failureUrl(\"/login/error\").permitAll(); http.logout().logoutSuccessUrl(\"/login\"); http.csrf().disable(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth // 从数据库读取的用户进行身份认证 .userDetailsService(userDatailService) .passwordEncoder(new BCryptPasswordEncoder()); } } 角色访问 @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 修改Controller.java类，增加方法的访问权限@PreAuthorize(\"hasAnyRole('admin')\") ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:3","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"Java集合框架 导入包 import java.util.*; ArrayList 一、定义一个ArrayList //默认创建一个ArrayList集合 List\u003cString\u003e list = new ArrayList\u003c\u003e(); //创建一个初始化长度为100的ArrayList集合 List\u003cString\u003e initlist = new ArrayList\u003c\u003e(100); //将其他类型的集合转为ArrayList List\u003cString\u003e setList = new ArrayList\u003c\u003e(new HashSet()); 二、ArrayList常用方法 add(E element) set(int index, E element) 因为ArrayList底层是由数组实现的，set实现非常简单，调用 set(4, \"4\") 通过传入的数字下标找到对应的位置，替换其中的元素，前提也需要首先判断传入的数组下标是否越界。 get(int index) remove(int index) remove(Object o) 其他方法 size() : 获取集合长度，通过定义在ArrayList中的私有变量size得到 isEmpty()：是否为空，通过定义在ArrayList中的私有变量size得到 contains(Object o)：是否包含某个元素，通过遍历底层数组elementData，通过equals或==进行判断 clear()：集合清空，通过遍历底层数组elementData，设置为null ArrayList的遍历 List\u003cString\u003e list=new ArrayList\u003cString\u003e(); list.add(\"Hello\"); list.add(\"World\"); list.add(\"HAHAHAHA\"); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) { //也可以改写 for(int i=0;i\u003clist.size();i++) 这种形式 System.out.println(str); } //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i\u003cstrArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 { System.out.println(strArray[i]); } //第三种遍历 使用迭代器进行相关遍历 Iterator\u003cString\u003e ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 { System.out.println(ite.next()); } HashMap 一、定义一个HashMap Map\u003cString, String\u003e map = new HashMap\u003c\u003e(); 二、HashMap常用方法 public V put(K key, V value) :插入键值对数据 public V get(Object key) :根据键值获取键值对值数据 public int size() :获取Map中键值对的个数 public boolean containsKey(Object key) :判断Map集合中是否包含键为key的键值对 boolean containsValue(Object value) :判断Map集合中是否包含值为value的键值对 public boolean isEmpty() :判断Map集合中是否没有任何键值对 public V remove(Object key) :根据键值删除Map中键值对 public void clear() :清空Map集合中所有的键值对 HashMap的遍历 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); //第一种：普遍使用，二次取值 System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) { System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); } //第二种 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator\u003cMap.Entry\u003cString, String\u003e\u003e it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry\u003cString, String\u003e entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry\u003cString, String\u003e entry : map.entrySet()) { System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第四种 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) { System.out.println(\"value= \" + v); } ","date":"2020-10-12","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"Java多线程 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 一个线程的生命周期 线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态： 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态： 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态： 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态： 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态： 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 Thread 方法 序号 方法描述 1 **public void start()**使该线程开始执行；==Java== 虚拟机调用该线程的 run 方法。 2 **public void run()**如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 **public final void setName(String name)**改变线程名称，使之与参数 name 相同。 4 **public final void setPriority(int priority)** 更改线程的优先级。 5 **public final void setDaemon(boolean on)**将该线程标记为守护线程或用户线程。 6 **public final void join(long millisec)**等待该线程终止的时间最长为 millis 毫秒。 7 **public void interrupt()**中断线程。 8 **public final boolean isAlive()**测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 **public static void yield()**暂停当前正在执行的线程对象，并执行其他线程。 2 **public static void sleep(long millisec)**在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 **public static boolean holdsLock(Object x)**当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 **public static Thread currentThread()**返回对当前正在执行的线程对象的引用。 5 **public static void dumpStack()**将当前线程的堆栈跟踪打印至标准错误流。 创建一个线程 Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现Runnable 接口来创建线程 创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： public void run() 你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是我们经常使用的： Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 void start(); 下面是一个创建线程并开始让它执行的实例： class RunnableDemo implements Runnable { private Thread t; private String threadName; RunnableDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i \u003e 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } } } public class TestThread { public static void main(String args[]) { RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); } } 通过继承Thread来创建线程 创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 class ThreadDemo extends Thread { private Thread t; private String threadName; ThreadDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i \u003e 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + ","date":"2020-10-12","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"一、写前准备 在atom文本编译器中自带着markdown的编写与浏览功能。 浏览使用快捷键ctl+shift+m就可以打开markdown预览。 简书中在设置-\u003e默认编辑器-\u003emarkdown编译，就可以设置markdown。 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:1:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"二、标题 在想要设置为标题的文字前面加#来表示标题 一个#号是以及标题，两个#是二级标题，最多有六级标题 标准语法需要在#后加空格才能表示 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:2:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"三、字体 加粗 在要加粗的文字左右分别用两个*标注 斜体 在要倾斜的文字左右分别用一个*标注 斜体加粗 在要倾斜和加粗的文字左右分别用三个*标注 删除线 在要加删除线的文字左右分别用两个～标注 例如： **加粗字体** *斜体字体* ***斜体加粗字体*** ~~删除字体~~ 效果： 加粗字体，斜体字体，斜体加粗字体，删除字体 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:3:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"四、引用 在引用文字前加\u003e。引用可以嵌套，如一个\u003e、两个\u003e等等 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:4:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"五、\u0008分割线 三个或三个以上的-或者*\u0008\u0008 例： --- *** \u0008效果: ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:5:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"六、\u0008图片 使用方法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:6:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"七、超链接 使用方法： [超链接名](超链接地址 \"超链接title\") title可加可不加 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 \u003ca href=\"超链接地址\" target=\"_blank\"\u003e超链接名\u003c/a\u003e 示例 \u003ca href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\"\u003e简书\u003c/a\u003e ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:7:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"八、列表 无序列表 使用方法：无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表 使用方法：数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 列表嵌套 使用方法：上一级和下一级之间敲三个空格 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:8:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"九、表格 使用方法： |表头|表头|表头| |-|:-:|-:| |内容|内容|内容| |内容|内容|内容| 第二行分割表头和内容。 -有一个就行 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:9:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十、代码 使用方法： 单行代码：代码之间分别用一个反引号包起来 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 代码\u0008高亮：在第一行反引号后面输入代码块所使用的语言 代码高亮演示： `c #include \"stdio.h\" int main(){ printf(\"hello world\\n\"); return 0; } ` #include \"stdio.h\" int main(){ printf(\"hello world\\n\"); return 0; } ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:10:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十一、流程图 使用方法： st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:11:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十二、数学表达式 用反引号将数学表达式封装,并在第三个号后标注math代表数学公式. E = mc^2 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:12:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十三、待办事项 在待办的事项文本或者清单文本前加上- 、- [x]即可 - [ ] 表示未完成，- [x] 表示已完成。 注：键入字符与字符之间都要保留一个字符的空格。 \u0008效果 分析需求 研发 测试 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:13:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"结语 Markdown换行方法： 在本行最后\u0008敲两个空格即可 每行间空一行即可 Mac上反引号方法： 在英文状态下按住option键+数字\u00081左边的键 本文章为个人学习笔记，转载了多人的博客，如有雷同请见谅。 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:14:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"}]