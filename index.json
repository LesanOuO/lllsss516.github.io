[{"categories":["实践笔记"],"content":"消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为.NET Core 3.1下 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:0:0","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"SignalR实现 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:1:0","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"简介 SignalR是一个开源的库，跨平台；让Web应用与其他应用通讯变得很简单，Web服务端可以实时的将内容推送给对应的客户端，客户端发送的信息也可以实时到其他客户端。 SignalR提供了一种远程过程调用(RPC)的方式，使得客户端可以调用服务器的方法，同样在服务器端的方法中也能调用客户端的方法。 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:1:1","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"示例 Nuget包为：\u003cPackageReference Include=\"Microsoft.AspNetCore.SignalR.Core\" Version=\"1.1.0\" /\u003e 首先我们需要创建一个自己的SignalR Hub using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace KBEAM.Hubs { public class ChatHub : Hub // 继承自SignalR Hub库 { public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\"ReceiveMessage\", user, message); } public async Task SendMessageToGroup(string group, string message) { await Clients.Group(group).SendAsync(\"ReceiveMessageFromGroup\", group, message); } public async Task AddToGroup(string groupName) { await Groups.AddToGroupAsync(Context.ConnectionId, groupName); await Clients.Group(groupName).SendAsync(\"ReceiveMessage\", $\"{Context.ConnectionId} has joined the group {groupName}.\"); } public async Task RemoveFromGroup(string groupName) { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); //await Clients.Group(groupName).SendAsync(\"ReceiveMessage\", $\"{Context.ConnectionId} has left the group {groupName}.\"); } } } 在Startup.cs文件中注册相关服务及管道 // 1.在ConfigureServices函数中添加以下语句，注册相关服务 services.AddSignalR(); // 2.在Configure函数中添加以下语句，配置管道终结点 app.UseEndpoints(endpoints =\u003e { // ... endpoints.MapHub\u003cChatHub\u003e(\"/chatHub\"); // ... }); 编写服务端业务，推送消息 // 定义一个上下文 private readonly IHubContext\u003cChatHub\u003e hubContext; // 通过构造函数注入依赖 public MonitorService(IHubContext\u003cChatHub\u003e hub) { hubContext = hub; } //在需要的地方调用方法，进行消息推送 await hubContext.Clients.Group(group).SendAsync(\"ReceiveMessageFromGroup\",group, \"需要发送的消息\"); JS客户端程序编写 首先，需要通过npm来安装SignalR封装好的JS文件，npm install @microsoft/signalr // 1.首先进行SignalR客户端连接 const signalR = require(\"@microsoft/signalr\") let conn = new signalR.HubConnectionBuilder() .withUrl(\"http://localhost:8988/chatHub\") .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build() export default conn import signalR from \"@/utils/signalR\"; // 2.客户端调用服务端方法（RPC） signalR.invoke(\"AddToGroup\", \"groupName\").catch(function (err) { // 加入用户组 return console.error(err.toString()); }); signalR.invoke(\"RemoveFromGroup\", \"大屏\").catch(function (err) { // 移除用户组 return console.error(err.toString()); }); // 3.客户端监听服务器消息 signalR.on(\"ReceiveMessageFromGroup\", function (group, message) { console.log(group + \" \" + message); that.lineChartData = JSON.parse(message); }); ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:1:2","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"RabbitMQ实现 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:2:0","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"简介 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），由以高性能、健壮以及可伸缩性出名的 Erlang 写成。 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:2:1","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"示例 首先您需要在电脑上安装好 Erlang及RabbitMQ服务器，这一步大家就自行搜索解决吧，网上应该有很多的解决方法 RabbitMQ准备 首先开启Stomp插件 rabbitmq-plugins enable rabbitmq_management # 开启此插件后有管理界面http://localhost:15672/ rabbitmq-plugins enable rabbitmq_web_stomp rabbitmq-plugins enable rabbitmq_web_stomp_examples 服务端发送消息 所需Nuget包：\u003cPackageReference Include=\"RabbitMQ.Client\" Version=\"6.2.4\" /\u003e // 建立RabbitMQ连接 private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"用户名\", Password = \"密码\", Port = 5672, VirtualHost = \"虚拟主机配置\" }; // 发送消息 using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(\"monitor\", ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(\"message\", durable: true, autoDelete: false, exclusive: false, arguments: null); channel.QueueBind(\"message\", \"monitor\", routingKey: \"message\"); var props = channel.CreateBasicProperties(); props.Persistent = true; channel.BasicPublish(exchange: \"monitor\", routingKey: \"message\", basicProperties: props, body: Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(new { expectedData, actualData }))); } } 具体RabbitMQ使用可以看我的RabbitMQ学习笔记 客户端接受消息 首先需要安装npm库文件，npm install stompjs import Stomp from \"stompjs\"; // 定义一个RabbitMQ客户端 data() { return { client: Stomp.client(\"ws://localhost:15674/ws\"), }; }, // 初始化连接操作 created() { this.client.connect( \"用户名\", \"密码\", this.onConnected, this.onFailed, \"虚拟主机名称\" ); } methods: { onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\"Lesan\"); console.log(\"连接成功\"); this.client.subscribe( \"/exchange/monitor/message\", this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\"MQ Failed: \" + frame); this.$message.error(\"连接失败\"); }, // 回传消息 responseCallback: function (frame) { console.log(\"MQ msg=\u003e\" + frame.body); this.lineChartData = JSON.parse(frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.client.disconnect(function () { console.log(\"已退出账号\"); }); }, }, ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:2:2","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"MQTT实现 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:3:0","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"简介 MQTT是IBM开发的一个即时通讯协议，该协议支持所有的平台，几乎可以把所有联网的物品和外部连接起来。 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP。 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 三种消息传输方式QoS： 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送 1代表“至少一次”，确保消息到达，但消息重复可能会发生 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果 ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:3:1","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"示例 服务端开发 所需Nuget包：\u003cPackageReference Include=\"MQTTnet.AspNetCore\" Version=\"3.1.2\" /\u003e 对Program.cs修改： public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u003e { webBuilder.UseKestrel(o =\u003e { o.ListenAnyIP(8988); o.ListenAnyIP(1884, t =\u003e t.UseMqtt()); }); webBuilder.UseStartup\u003cStartup\u003e(); //webBuilder.UseUrls(\"http://0.0.0.0:8988\"); }); 对Startup.cs修改： // 在ConfigureServices函数中添加 services.AddHostedMqttServer(mqttServer =\u003e mqttServer.WithoutDefaultEndpoint().WithConnectionValidator(c =\u003e { if (c.Username != \"admin\" || c.Password != \"123456\") { c.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword; return; } c.ReasonCode = MqttConnectReasonCode.Success; })) .AddMqttConnectionHandler() .AddConnections(); // 在Configure函数中添加 app.UseEndpoints(endpoints =\u003e { endpoints.MapConnectionHandler\u003cMqttConnectionHandler\u003e( \"/mqtt\", httpConnectionDispatcherOptions =\u003e httpConnectionDispatcherOptions.WebSockets.SubProtocolSelector = protocolList =\u003e protocolList.FirstOrDefault() ?? string.Empty); }); app.UseMqttServer(S =\u003e { MqttHelper.Server = S; S.ClientConnectedHandler = new MqttServerClientConnectedHandlerDelegate(OnConnected); S.StartedHandler = new MqttServerStartedHandlerDelegate(OnStarted); }); // 添加事件处理函数 private void OnStarted(EventArgs obj) { RecurringJob.AddOrUpdate\u003cMonitorService\u003e(\"MonitorData\", p =\u003e p.UpdateDataAsync(\"大屏\"), \"0/15 * * * * *\"); } private void OnConnected(MqttServerClientConnectedEventArgs args) { Console.WriteLine(args.ClientId); } // 消息推送方法 MqttHelper.PublishAsync(\"monitor\", JsonConvert.SerializeObject(new { expectedData, actualData })); 添加MqttHelper类： using MQTTnet.Server; using System.Text; namespace Common { public class MqttHelper { public static IMqttServer Server { get; set; } public static void PublishAsync(string topic, byte[] payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = payload }, new System.Threading.CancellationToken(false)); } } public static void PublishAsync(string topic, string payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = Encoding.UTF8.GetBytes(payload) }, new System.Threading.CancellationToken(false)); ; } } } } 客服端开发 首先需要引入npm包：npm install mqtt import mqtt from \"mqtt\"; // 连接Mqtt服务器，并订阅消息 mounted() { let that = this; let mqttClient = mqtt.connect(\"ws://localhost:8988/mqtt\", { username: \"用户名\", password: \"密码\", clientId: \"客户端ID\", }); mqttClient.on(\"connect\", (e) =\u003e { console.log(\"connected\", e); mqttClient.subscribe(\"monitor\", { qos: 1 }, (err) =\u003e { if (!err) { console.log(\"subscribed\"); } }); }); mqttClient.on(\"message\", (topic, message) =\u003e { console.log(topic, message.toString()); that.lineChartData = JSON.parse(message.toString()); }); }, ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:3:2","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["实践笔记"],"content":"其他 Vue前端测试客户端全部代码，通过Vue-cli搭建的项目，修改App.vue即可 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cimg alt=\"Vue logo\" src=\"./assets/logo.png\" /\u003e \u003cHelloWorld msg=\"Welcome to Your Vue.js App\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import HelloWorld from \"./components/HelloWorld.vue\"; import mqtt from \"mqtt\"; import Stomp from \"stompjs\"; export default { name: \"App\", components: { HelloWorld, }, data() { return { rabbitClient: Stomp.client(\"ws://172.21.30.233:15674/ws\"), }; }, created() {}, mounted() { // this.useMqtt(); // this.useRabbitMQ(); this.useSignalR(); }, methods: { useSignalR() { const signalR = require(\"@microsoft/signalr\"); const conn = new signalR.HubConnectionBuilder() .withUrl(\"http://172.21.30.233:8988/chatHub\") .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build(); conn .start() .then(() =\u003e { console.log(\"conneted\"); conn.invoke(\"AddToGroup\", \"大屏\").catch(function (err) { return console.error(err.toString()); }); conn.on(\"ReceiveMessageFromGroup\", function (group, message) { console.log(group + \" \" + message); }); }) .catch((err) =\u003e { return console.error(err.toString()); }); }, useMqtt() { let mqttClient = mqtt.connect(\"ws://172.21.30.233:8988/mqtt\", { username: \"admin\", password: \"123456\", // clientId: \"Lesan\", }); mqttClient.on(\"connect\", (e) =\u003e { console.log(\"connected\", e); mqttClient.subscribe(\"monitor\", { qos: 1 }, (err) =\u003e { if (!err) { console.log(\"subscribed\"); } }); }); mqttClient.on(\"message\", (topic, message) =\u003e { console.log(topic, message.toString()); }); }, useRabbitMQ() { // this.rabbitClient.heartbeat.outgoing = 0; // this.rabbitClient.heartbeat.incoming = 0; this.rabbitClient.connect( \"KB\", \"KB\", this.onConnected, this.onFailed, \"kb_monitor\" ); }, onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\"Lesan\"); console.log(\"连接成功\"); this.rabbitClient.subscribe( \"/exchange/monitor/message\", this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\"MQ Failed: \" + frame); this.$message.error(\"连接失败\"); }, // 回传消息 responseCallback: function (frame) { console.log(\"MQ msg=\u003e\" + frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.rabbitClient.disconnect(function () { console.log(\"已退出账号\"); }); }, }, }; \u003c/script\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u003c/style\u003e ","date":"2022-03-19","objectID":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/:4:0","tags":["消息推送"],"title":"实现简单消息推送功能","uri":"/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD/"},{"categories":["学习笔记"],"content":"RabbitMQ简述 MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。AMQP(高级消息队列协议) 是一个异步消息传递所使用的应用层协议规范，作为线路层协议，而不是API（例如JMS），AMQP 客户端能够无视消息的来源任意发送和接受信息。AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议，而现在的目标则是为通用消息队列架构提供通用构建工具。因此，面向消息的中间件 （MOM）系统，例如发布/订阅队列，没有作为基本元素实现。AMQP当中有四个概念非常重要（一个虚拟主机持有一组交换机、队列和绑定）： virtual host，虚拟主机 exchange，交换机 queue，队列 binding，绑定 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:1:0","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"消息传递过程 上图为RabbitMQ中一些重要名词的概述，其中包括Connection、Channel、Exchange、Queue、Bind、Routing Key 上图为消息从生产到消费的整个流程，其中Exchange，与Queue都是可以设置相关属性，队列的持久化，交换器类型制定 这个过程走分三个部分，1、客户端（生产消息队列），2、RabbitMQ服务端（负责路由规则的绑定与消息的分发），3、客户端（消费消息队列中的消息） 由图可以看出，一个消息可以走一次网络却被分发到不同的消息队列中，然后被多个的客户端消费，那么这个过程就是RabbitMQ的核心机制，RabbitMQ的路由类型与消费模式 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:2:0","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"RabbitMQ中Exchange的类型 类型有4种，direct，fanout，topic，headers。其中headers不常用，本篇不做介绍，其他三种类型，会做详细介绍。 那么这些类型是什么意思呢？就是Exchange与队列进行绑定后，消息根据exchang的类型，按照不同的绑定规则分发消息到消息队列中，可以是一个消息被分发给多个消息队列，也可以是一个消息分发到一个消息队列。具体请看下文。 介绍之初还要说下RoutingKey，这是个什么玩意呢？他是exchange与消息队列绑定中的一个标识。有些路由类型会按照标识对应消息队列，有些路由类型忽略routingkey。具体看下文。 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:3:0","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Exchange类型direct 根据交换器名称与routingkey来找队列的 Note:消息从client发出，传送给交换器ChangeA，RoutingKey为routingkey.ZLH,那么不管你发送给Queue1，还是Queue2一个消息都会保存在Queue1，Queue2，Queue3，三个队列中。这就是交换器的direct类型的路由规则。只要找到路由器与routingkey绑定的队列，那么他有多少队列，他就分发给多少队列。 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:3:1","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Exchange类型fanout 这个类型忽略Routingkey，他为广播模式 Note:消息从客户端发出，只要queue与exchange有绑定，那么他不管你的Routingkey是什么他都会将消息分发给所有与该exchang绑定的队列中。 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:3:2","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Exchange类型topic 这个类型的路由规则如果你掌握啦，那是相当的好用，与灵活。他是根据RoutingKey的设置，来做匹配的，其中这里还有两个通配符为： *，代表任意的一个词。例如topic.zlh.*，他能够匹配到，topic.zlh.one ,topic.zlh.two ,topic.zlh.abc, …. #，代表任意多个词。例如topic.#，他能够匹配到，topic.zlh.one ,topic.zlh.two ,topic.zlh.abc, …. Note：这个图看上去很乱，但是他是根据匹配符做匹配的，这里我建议你自己做下消息队列的具体操作。ss ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:3:3","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"消息队列的消费与消息确认 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:4:0","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"消息队列的消费 Note:如果一个消息队列中有大量消息等待操作时，我们可以用多个客户端来处理消息，这里的分发机制是采用负载均衡算法中的轮询。第一个消息给A，下一个消息给B，下下一个消息给A，下下下一个消息给B……以此类推 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:4:1","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"消息确认 保证消息的安全性，保证此消息被正确处理后才能在服务端的消息队列中删除。那么rabbitmq提供啦ack应答机制，来实现这一功能。 ack应答有两种方式：1、自动应答，2、手动应答 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:4:2","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"使用例子 ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:5:0","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"生产者 using RabbitMQ.Client; using System; using System.Text; namespace RabbitMQProduct { internal class Program { static void Main(string[] args) { Console.WriteLine(\"Welcome to RabbitMQ Product!\"); DirectExchangeSendMsg(); // TopicExchangeSendMsg(); Console.WriteLine(\"按任意值，退出程序\"); Console.ReadKey(); } /// \u003csummary\u003e /// 连接配置 /// \u003c/summary\u003e private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { UserName = \"guest\", Password = \"guest\", Port = 5672, //VirtualHost = \"LesanVirtualHost\" }; /// \u003csummary\u003e /// 路由名称 /// \u003c/summary\u003e const string ExchangeName = \"Lesan.exchange\"; //队列名称 const string QueueName = \"Lesan.queue\"; /// \u003csummary\u003e /// 路由名称 /// \u003c/summary\u003e const string TopExchangeName = \"topic.Lesan.exchange\"; //队列名称 const string TopQueueName = \"topic.Lesan.queue\"; /// \u003csummary\u003e /// 单点精确路由模式 /// \u003c/summary\u003e public static void DirectExchangeSendMsg() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //设置交换器的类型 channel.ExchangeDeclare(ExchangeName, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); //声明一个队列，设置队列是否持久化，排他性，与自动删除 channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); //绑定消息队列，交换器，routingkey channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); var props = channel.CreateBasicProperties(); //队列持久化 props.Persistent = true; string vadata = Console.ReadLine(); while (vadata != \"exit\") { var msgBody = Encoding.UTF8.GetBytes(vadata); //发送信息 channel.BasicPublish(exchange: ExchangeName, routingKey: QueueName, basicProperties: props, body: msgBody); Console.WriteLine(string.Format(\"***发送时间:{0}，发送完成，输入exit退出消息发送\", DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"))); vadata = Console.ReadLine(); } } } } /// \u003csummary\u003e /// topic 模糊匹配模式，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.*” 只会匹配到“log.error” /// \u003c/summary\u003e public static void TopicExchangeSendMsg() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(TopExchangeName, ExchangeType.Topic, durable: false, autoDelete: false, arguments: null); channel.QueueDeclare(TopQueueName, durable: false, autoDelete: false, exclusive: false, arguments: null); channel.QueueBind(TopQueueName, TopExchangeName, routingKey: TopQueueName); //var props = channel.CreateBasicProperties(); //props.Persistent = true; string vadata = Console.ReadLine(); while (vadata != \"exit\") { var msgBody = Encoding.UTF8.GetBytes(vadata); channel.BasicPublish(exchange: TopExchangeName, routingKey: TopQueueName, basicProperties: null, body: msgBody); Console.WriteLine(string.Format(\"***发送时间:{0}，发送完成，输入exit退出消息发送\", DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"))); vadata = Console.ReadLine(); } } } } } } ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:5:1","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"消费者 using RabbitMQ.Client; using RabbitMQ.Client.Events; using System; using System.Text; namespace RabbitMQConsumer { internal class Program { static void Main(string[] args) { Console.WriteLine(\"Welcome to RabbitMQ Consumer!\"); //DirectAcceptExchange(); //DirectAcceptExchangeEvent(); DirectAcceptExchangeTask(); //TopicAcceptExchange(); Console.WriteLine(\"按任意值，退出程序\"); Console.ReadKey(); } /// \u003csummary\u003e /// 连接配置 /// \u003c/summary\u003e private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { UserName = \"guest\", Password = \"guest\", Port = 5672, //VirtualHost = \"LesanVirtualHost\" }; /// \u003csummary\u003e /// 路由名称 /// \u003c/summary\u003e const string ExchangeName = \"Lesan.exchange\"; //队列名称 const string QueueName = \"Lesan.queue\"; /// \u003csummary\u003e /// 路由名称 /// \u003c/summary\u003e const string TopExchangeName = \"topic.Lesan.exchange\"; //队列名称 const string TopQueueName = \"topic.Lesan.queue\"; /// \u003csummary\u003e /// 基于时间轮询的，每隔一段时间获取一次 /// \u003c/summary\u003e public static void DirectAcceptExchange() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //设置交换器的类型 channel.ExchangeDeclare(ExchangeName, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); //声明一个队列，设置队列是否持久化，排他性，与自动删除 channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); //绑定消息队列，交换器，routingkey channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); while (true) { BasicGetResult msgResponse = channel.BasicGet(QueueName, true); if (msgResponse != null) { var msgBody = Encoding.UTF8.GetString(msgResponse.Body.ToArray()); Console.WriteLine(string.Format(\"***接收时间:{0}，消息内容：{1}\", DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"), msgBody)); } System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1)); } } } } /// \u003csummary\u003e /// 基于事件的，当消息到达时触发事件，获取数据 /// \u003c/summary\u003e public static void DirectAcceptExchangeEvent() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //channel.ExchangeDeclare(ExchangeName, \"direct\", durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); //channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u003e { var msgBody = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(string.Format(\"***接收时间:{0}，消息内容：{1}\", DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"), msgBody)); }; channel.BasicConsume(QueueName, true, consumer: consumer); Console.WriteLine(\"按任意值，退出程序\"); Console.ReadKey(); } } } /// \u003csummary\u003e /// 基于事件的，当消息到达时触发事件，获取数据 /// \u003c/summary\u003e public static void DirectAcceptExchangeTask() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //channel.ExchangeDeclare(ExchangeName, \"direct\", durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);//告诉broker同一时间只处理一个消息 //channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); //定义这个队列的消费者 var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u003e { var msgBody = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(string.Format(\"***接收时间:{0}，消息内容：{1}\", DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"), msgBody)); int dots = msgBody.Split('.').Length - 1; System.Threading.Thread.Sleep(dots * 1000); //处理完成，告诉Broker可以服务端可以删除消息，分配新的消息过来 channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false); }; //noAck设置false,告诉broker，发送消息之后，消息暂时不要删除，等消费者处理完成再说 //false为手动应答，true为自动应答 channel.BasicConsume(QueueName, false, consumer: consumer); Console.WriteLine(\"按任意值，退出程序\"); Console.ReadKey(); } } } /// \u003csummary\u003e /// topic 模糊匹配模式，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.*” 只会匹配到“log.error” /","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:5:2","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"引用 以上笔记摘录自网络 https://www.cnblogs.com/knowledgesea/p/5296008.html https://www.cnblogs.com/personblog/p/10681741.html ","date":"2022-02-17","objectID":"/rabbitmq%E5%AD%A6%E4%B9%A0/:6:0","tags":["RabbitMQ",".NET"],"title":"RabbitMQ学习","uri":"/rabbitmq%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"本文为个人学习和实践 Nginx 的笔记 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:0:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Nginx 常用功能 Nginx 有以下几个常用功能 反向代理 这是它的主要功能之一，客户端向服务器发送请求时，会先通过 Nginx 服务器，由服务器将请求分发到相应的Web服务器。正向代理是代理客户端，而反向代理则是代理服务器，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。 负载均衡 这也是 Nginx 最常用的功能之一，负载均衡，一方面是将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后将结果汇总返回给用户，这样可以大幅度提高网络系统的处理能力；另一方面将大量的前端并发请求或数据流量分担到多个后端网络节点分别处理，这样可以有效减少前端用户等待相应的时间。而 Nginx 负载均衡都是属于后一方面，主要是对大量前端访问或流量进行分流，已保证前端用户访问效率，并可以减少后端服务器处理压力。 Web缓存 在很多优秀的网站中，Nginx 可以作为前置缓存服务器，它被用于缓存前端请求，从而提高 Web服务器的性能。Nginx 会对用户已经访问过的内容在服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 Nginx 服务器向后端发出请求。减轻网络拥堵，减小数据传输延时，提高用户访问速度。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:1:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Nginx 安装 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:2:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"下载地址 Nginx 下载地址：http://nginx.org/en/download.html ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:2:1","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Windows 版本安装 解压下载的文件后 下面对上面文件夹进行介绍： conf 目录：存放 Nginx 的主要配置文件，很多功能实现都是通过配置该目录下的 nginx.conf 文件，后面我们会详细介绍。 docs目录：存放 Nginx 服务器的主要文档资料，包括 Nginx 服务器的 LICENSE、OpenSSL 的 LICENSE 、PCRE 的 LICENSE 以及 zlib 的 LICENSE ，还包括本版本的 Nginx服务器升级的版本变更说明，以及 README 文档。 html目录：存放了两个后缀名为 .html 的静态网页文件，这两个文件与 Nginx 服务器的运行相关。 logs目录：存放 Nginx 服务器运行的日志文件。 nginx.exe：启动 Nginx 服务器的exe文件，如果 conf 目录下的 nginx.conf 文件配置正确的话，通过该文件即可启动 Nginx 服务器。 关闭 nginx 的方法： 进入到 nginx 目录并且输入以下命令：nginx.exe -s stop ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:2:2","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Linux 版本安装 首先需要安装 nginx 的依赖环境： yum install gcc-c++ yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel 对于 gcc，因为安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境的话，需要安装gcc。 对于 pcre，prce(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。 对于 zlib，zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 对于 openssl，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 编译及安装： 1. 首先将下载的文件放到 Linux 系统中，然后解压： tar -zxvf nginx-1.14.0.tar.gz 2. 接着进入解压之后的目录进行编译安装 ./configure --prefix=/usr/local/nginx make make install 3. 进入到/usr/local/nginx目录，再进入sbin目录，通过以下命令启动nginx: ./nginx 通过 ps -ef | grep nginx 查看nginx的进程 4. 关闭nginx： 快速关闭：cd /usr/local/nginx/sbin ./nginx -s stop 相当于直接kill掉nginx的进程id 平缓关闭：cd /usr/local/nginx/sbin ./nginx -s quit 等nginx服务处理完所有请求后再关闭连接，停止工作 5. 重启nginx 先停止再启动：./nginx -s quit ./nginx 重新加载配置文件：./nginx -s reload 6. 检测配置文件语法是否正确 指定需要检测的配置文件：nginx -t -c /usr/local/nginx/conf/nginx.conf 检测默认nginx.conf配置文件：nginx -t ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:2:3","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"nginx.conf 配置文件 根据默认配置文件，我们可以将nginx.conf配置文件分为三部分： ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:3:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"全局块 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如：worker_processes 1; 这是Nginx服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:3:1","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"events 块 比如： events { worker_connections 1024; } events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:3:2","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"http 块 http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 这是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 http 块也可以包括 http全局块、server 块： http全局块 http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。后面会详细介绍虚拟主机的概念。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 全局server块：最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 location块：一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:3:3","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"反向代理 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:4:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"代理定义 Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器。 在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。 代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。那么这个例子里面的中介公司就是给我们做代理服务的，我们委托中介公司帮我们找房子。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:4:1","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"正向代理定义 　弄清楚什么是代理了，那么什么又是正向代理呢？ 　这里我再举一个例子：大家都知道，现在国内是访问不了 Google的，那么怎么才能访问 Google呢？我们又想，美国人不是能访问 Google吗（这不废话，Google就是美国的），如果我们电脑的对外公网 IP 地址能变成美国的 IP 地址，那不就可以访问 Google了。你很聪明，VPN 就是这样产生的。我们在访问 Google 时，先连上 VPN 服务器将我们的 IP 地址变成美国的 IP 地址，然后就可以顺利的访问了。 　这里的 VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。 　PS：这里介绍一下什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的 LOL，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的LOL就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。 　可能听到这里大家还是很抽象，没关系，和下面的反向代理对比理解就简单了。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:4:2","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"反向代理定义 　反向代理和正向代理的区别就是：正向代理代理客户端，反向代理代理服务器。 　反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。 　下面我们通过两张图来对比正向代理和方向代理： 理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。 总结起来还是一句话：正向代理代理客户端，反向代理代理服务器。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:4:3","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Nginx 反向代理 相关指令 listen 该指令用于配置网络监听。主要有如下三种配置语法结构： ① 配置监听的IP地址 listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl]; ② 配置监听端口 listen port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deffered] [bind] [ipv6only=on|off] [ssl]; ③ 配置 UNIX Domain Socket listen unix:path [default_server] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deffered] [bind] [ssl] 上面的配置看似比较复杂，其实使用起来是比较简单的： listen *:80 | *:8080 #监听所有80端口和8080端口 listen IP_address:port #监听指定的地址和端口号 listen IP_address #监听指定ip地址所有端口 listen port #监听该端口的所有IP连接 下面分别解释每个选项的具体含义： 1、address:IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。 2、port:端口号，如果只定义了IP地址，没有定义端口号，那么就使用80端口。 3、path:socket文件路径，如 var/run/nginx.sock等。 4、default_server:标识符，将此虚拟主机设置为 address:port 的默认主机。（在 nginx-0.8.21 之前使用的是 default 指令） 5、 setfib=number:Nginx-0.8.44 中使用这个变量监听 socket 关联路由表，目前只对 FreeBSD 起作用，不常用。 6、backlog=number:设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在 FreeBSD 中默认为 -1,其他平台默认为511. 7、rcvbuf=size:设置监听socket接收缓存区大小。 8、sndbuf=size:设置监听socket发送缓存区大小。 9、deferred:标识符，将accept()设置为Deferred模式。 10、accept_filter=filter:设置监听端口对所有请求进行过滤，被过滤的内容不能被接收和处理，本指令只在 FreeBSD 和 NetBSD 5.0+ 平台下有效。filter 可以设置为 dataready 或 httpready 。 11、bind:标识符，使用独立的bind() 处理此address:port，一般情况下，对于端口相同而IP地址不同的多个连接，Nginx 服务器将只使用一个监听指令，并使用 bind() 处理端口相同的所有连接。 12、ssl:标识符，设置会话连接使用 SSL模式进行，此标识符和Nginx服务器提供的 HTTPS 服务有关。 server_name 该指令用于虚拟主机的配置。通常分为以下两种： 1、基于名称的虚拟主机配置 语法格式如下： server_name name ...; 一、对于name 来说，可以只有一个名称，也可以有多个名称，中间用空格隔开。而每个名字由两段或者三段组成，每段之间用“.”隔开。 server_name 123.com www.123.com 二、可以使用通配符“*”，但通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端。 server_name *.123.com www.123.* 三、还可以使用正则表达式，用“~”作为正则表达式字符串的开始标记。 server_name ~^www\\d+\\.123\\.com$; 该表达式“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，在紧跟“.123.co”，最后跟着“m”($表示结尾) 以上匹配的顺序优先级如下： 1 ①、准确匹配 server_name 2 ②、通配符在开始时匹配 server_name 成功 3 ③、通配符在结尾时匹配 server_name 成功 4 ④、正则表达式匹配 server_name 成功 2、基于 IP 地址的虚拟主机配置 语法结构和基于域名匹配一样，而且不需要考虑通配符和正则表达式的问题。 server_name 192.168.1.1 location 该指令用于匹配 URL。 　语法如下： location [ = | ~ | ~* | ^~] uri { } 　1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 　2、~：用于表示 uri 包含正则表达式，并且区分大小写。 　3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 　4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 　注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 proxy_pass 　该指令用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。 　语法结构如下： proxy_pass URL; 　URL 为被代理服务器的地址，可以包含传输协议、主机名称或IP地址加端口号，URI等。 proxy_pass http://www.123.com/uri; index 　该指令用于设置网站的默认首页。 　语法为： index filename ...; 　后面的文件名称可以有多个，中间用空格隔开。 index index.html index.jsp; 　通常该指令有两个作用：第一个是用户在请求访问网站时，请求地址可以不写首页名称；第二个是可以对一个请求，根据请求内容而设置不同的首页。 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:4:4","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"配置案例 server { listen 80; server_name localhost; charset utf-8; location / { root /home/ruoyi/projects/ruoyi-ui; try_files $uri $uri/ /index.html; index index.html index.htm; } location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:4:5","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"负载均衡 ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:5:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"负载均衡的由来 早期的系统架构，基本上都是如下形式的： 客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。 负载均衡完美的解决了单个服务器硬件性能瓶颈的问题，但是随着而来的如何实现负载均衡呢？客户端怎么知道要将请求发送到那个服务器去处理呢？ ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:5:1","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"Nginx 实现负载均衡 Nginx 服务器是介于客户端和服务器之间的中介，通过上一节的反向代理的功能，客户端发送的请求先经过 Nginx ，然后通过 Nginx 将请求根据相应的规则分发到相应的服务器。 主要配置指令为上一讲的 pass_proxy 指令以及 upstream 指令。负载均衡主要通过专门的硬件设备或者软件算法实现。通过硬件设备实现的负载均衡效果好、效率高、性能稳定，但是成本较高。而通过软件实现的负载均衡主要依赖于均衡算法的选择和程序的健壮性。均衡算法又主要分为两大类： 静态负载均衡算法：主要包括轮询算法、基于比率的加权轮询算法或者基于优先级的加权轮询算法。 动态负载均衡算法：主要包括基于任务量的最少连接优化算法、基于性能的最快响应优先算法、预测算法及动态性能分配算法等。 静态负载均衡算法在一般网络环境下也能表现的比较好，动态负载均衡算法更加适用于复杂的网络环境。 例子： 普通轮询算法 upstream OrdinaryPolling { server 127.0.0.1:8080; server 127.0.0.1:8081; } server { listen 80; server_name localhost; location / { proxy_pass http://OrdinaryPolling; index index.html index.htm index.jsp; } } 基于比例加权轮询 upstream OrdinaryPolling { server 127.0.0.1:8080 weight=5; server 127.0.0.1:8081 weight=2; } server { listen 80; server_name localhost; location / { proxy_pass http://OrdinaryPolling; index index.html index.htm index.jsp; } } 基于IP路由负载 　我们知道一个请求在经过一个服务器处理时，服务器会保存相关的会话信息，比如session，但是该请求如果第一个服务器没处理完，通过nginx轮询到第二个服务器上，那么这个服务器是没有会话信息的。 　最典型的一个例子：用户第一次进入一个系统是需要进行登录身份验证的，首先将请求跳转到Tomcat1服务器进行处理，登录信息是保存在Tomcat1 上的，这时候需要进行别的操作，那么可能会将请求轮询到第二个Tomcat2上，那么由于Tomcat2 没有保存会话信息，会以为该用户没有登录，然后继续登录一次，如果有多个服务器，每次第一次访问都要进行登录，这显然是很影响用户体验的。 　这里产生的一个问题也就是集群环境下的 session 共享，如何解决这个问题？ 　通常由两种方法： 　1、第一种方法是选择一个中间件，将登录信息保存在一个中间件上，这个中间件可以为 Redis 这样的数据库。那么第一次登录，我们将session 信息保存在 Redis 中，跳转到第二个服务器时，我们可以先去Redis上查询是否有登录信息，如果有，就能直接进行登录之后的操作了，而不用进行重复登录。 　2、第二种方法是根据客户端的IP地址划分，每次都将同一个 IP 地址发送的请求都分发到同一个 Tomcat 服务器，那么也不会存在 session 共享的问题。 　而 nginx 的基于 IP 路由负载的机制就是上诉第二种形式。大概配置如下： upstream OrdinaryPolling { ip_hash; server 127.0.0.1:8080 weight=5; server 127.0.0.1:8081 weight=2; } server { listen 80; server_name localhost; location / { proxy_pass http://OrdinaryPolling; index index.html index.htm index.jsp; } } 注意：我们在 upstream 指令块中增加了 ip_hash 指令。该指令就是告诉 nginx 服务器，同一个 IP 地址客户端发送的请求都将分发到同一个 Tomcat 服务器进行处理。 基于服务器响应时间负载分配 根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。 upstream OrdinaryPolling { server 127.0.0.1:8080 weight=5; server 127.0.0.1:8081 weight=2; fair; } server { listen 80; server_name localhost; location / { proxy_pass http://OrdinaryPolling; index index.html index.htm index.jsp; } } 通过增加了 fair 指令。 对不同域名实现负载均衡 通过配合location 指令块我们还可以实现对不同域名实现负载均衡。 upstream wordbackend { server 127.0.0.1:8080; server 127.0.0.1:8081; } upstream pptbackend { server 127.0.0.1:8082; server 127.0.0.1:8083; } server { listen 80; server_name localhost; location /word/ { proxy_pass http://wordbackend; index index.html index.htm index.jsp; } location /ppt/ { proxy_pass http://pptbackend; index index.html index.htm index.jsp; } } ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:5:2","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["学习笔记"],"content":"引用 以上学习笔记多处摘录自网络 https://www.cnblogs.com/ysocean/p/9392912.html ","date":"2022-02-16","objectID":"/nginx%E5%AD%A6%E4%B9%A0/:6:0","tags":["Nginx"],"title":"Nginx学习","uri":"/nginx%E5%AD%A6%E4%B9%A0/"},{"categories":["算法学习"],"content":"本篇文章是学习leetcode中链表相关算法总结的链表技巧 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:0:0","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"虚拟头节点 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:1:0","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"力扣第 21 题「合并两个有序链表」 ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { ListNode *head = new ListNode(-1), *p = head; while (l1 \u0026\u0026 l2) { if (l1-\u003eval \u003c l2-\u003eval) { p-\u003enext = l1; l1 = l1-\u003enext; } else { p-\u003enext = l2; l2 = l2-\u003enext; } p = p-\u003enext; } p-\u003enext = l1 ? l1 : l2; return head-\u003enext; } 这个算法的逻辑类似于「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并 ListNode *head = new ListNode(-1), *p = head;中使用到了虚拟头节点，如果不使用虚拟节点，代码会复杂很多，而有了 head 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:1:1","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"优先队列 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:2:0","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"力扣第 23 题「合并K个升序链表」 struct cmp { bool operator()(ListNode *p1, ListNode *p2) { return p1-\u003eval \u003e p2-\u003eval; } }; ListNode *mergeKLists(vector\u003cListNode *\u003e \u0026lists) { if (lists.size() == 0) return nullptr; ListNode *head = new ListNode(-1), *tail = head; priority_queue\u003cListNode *, vector\u003cListNode *\u003e, cmp\u003e pq; for (auto i : lists) { if (i) pq.push(i); } while (!pq.empty()) { ListNode *node = pq.top(); pq.pop(); tail-\u003enext = node; tail = tail-\u003enext; if (node-\u003enext) pq.push(node-\u003enext); } return head-\u003enext; } 这里我们就要用到 优先级队列 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点 它的时间复杂度是多少呢？ 优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:2:1","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"单链表的倒数第k个节点 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:3:0","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"力扣第 19 题「删除链表的倒数第 N 个结点」 ListNode *removeNthFromEnd(ListNode *head, int n) { ListNode *dummy = new ListNode(-1); dummy-\u003enext = head; auto temp = FindFromEnd(dummy, n + 1); temp-\u003enext = temp-\u003enext-\u003enext; return dummy-\u003enext; } ListNode *FindFromEnd(ListNode *head, int n) { ListNode *first = head, *second = head; while (n--) { first = first-\u003enext; } while (first) { first = first-\u003enext; second = second-\u003enext; } return second; } 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？趁这个时候，再用一个指针 p2 指向链表头节点 head 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时走了 n - k 步，p2 也走了 n - k 步，也就是链表的倒数第 k 个节点 这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2 不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。 但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:3:1","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"双指针 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:4:0","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"力扣第 876 题「链表的中间结点」 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧： 我们让两个指针 slow 和 fast 分别指向链表头结点 head。 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 ListNode *middleNode(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026\u0026 fast-\u003enext) { slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; } return slow; } ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:4:1","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"力扣第 141 题「环形链表」 判断链表是否包含环属于经典问题了，解决方案也是用快慢指针： 每当慢指针 slow 前进一步，快指针 fast 就前进两步。 如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。 bool hasCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026\u0026 fast-\u003enext) { slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; if (slow == fast) return true; } return false; } 当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？ 这里简单提一下解法： ListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026\u0026 fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) { // fast 遇到空指针说明没有环 return null; } // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:4:2","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"力扣第 160 题「相交链表」 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *A = headA, *B = headB; while (A != B) { if (A) A = A-\u003enext; else A = headB; if (B) B = B-\u003enext; else B = headA; } return A; } 如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。 解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。 所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。 如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1： 那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？ 这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。 这样，这道题就解决了，空间复杂度为 O(1)，时间复杂度为 O(N)。 ","date":"2022-01-26","objectID":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/:4:3","tags":["链表"],"title":"算法学习-链表","uri":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"categories":["学习笔记"],"content":"API Collection 接口的接口 对象的集合（单列集合） ├——-List 接口：元素按进入先后有序保存，可重复 │—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全 │—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全 │—————-└ Vector 接口实现类 数组， 同步， 线程安全 │ ———————-└ Stack 是Vector类的实现类 └——-Set 接口： 仅接收一次，不可重复，并做内部排序 ├—————-└HashSet 使用hash表（数组）存储元素 │————————└ LinkedHashSet 链表维护元素的插入次序 └ —————-TreeSet 底层实现为二叉树，元素排好序 Map 接口 键值对的集合 （双列集合） ├———Hashtable 接口实现类， 同步， 线程安全 ├———HashMap 接口实现类 ，没有同步， 线程不安全- │—————–├ LinkedHashMap 双向链表和哈希表实现 │—————–└ WeakHashMap ├ ——–TreeMap 红黑树对所有的key进行排序 └———IdentifyHashMap ","date":"2021-01-13","objectID":"/java%E9%9B%86%E5%90%88/:0:0","tags":["Java"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["学习笔记"],"content":"HashSet HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。 HashSet 实现了 Set 接口。 HashSet 类位于 java.util 包中，使用前需要引入它，语法格式如下： import java.util.HashSet; // 引入 HashSet 类 以下实例我们创建一个 HashSet 对象 sites，用于保存字符串元素： HashSet\u003cString\u003e sites = new HashSet\u003cString\u003e(); 部分方法： HashSet\u003cString\u003e sites = new HashSet\u003cString\u003e(); sites.add(\"Google\"); sites.contains(\"Taobao\"); sites.remove(\"Taobao\"); sites.clear(); for (String i : sites) { System.out.println(i); } ","date":"2021-01-13","objectID":"/java%E9%9B%86%E5%90%88/:0:1","tags":["Java"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["学习笔记"],"content":"HashMap HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。 HashMap 是无序的，即不会记录插入的顺序。 HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 HashMap 类位于 java.util 包中，使用前需要引入它，语法格式如下： import java.util.HashMap; // 引入 HashMap 类 以下实例我们创建一个 HashMap 对象 Sites， 整型（Integer）的 key 和字符串（String）类型的 value： HashMap\u003cInteger, String\u003e Sites = new HashMap\u003cInteger, String\u003e(); 部分方法： // 创建 HashMap 对象 Sites HashMap\u003cInteger, String\u003e Sites = new HashMap\u003cInteger, String\u003e(); // 添加键值对 Sites.put(1, \"Google\"); Sites.get(3); Sites.remove(4); // 输出 key 和 value for (Integer i : Sites.keySet()) { System.out.println(\"key: \" + i + \" value: \" + Sites.get(i)); } // 返回所有 value 值 for(String value: Sites.values()) { // 输出每一个value System.out.print(value + \", \"); } Java HashMap 常用方法列表如下： 方法 描述 clear() 删除 hashMap 中的所有键/值对 clone() 复制一份 hashMap isEmpty() 判断 hashMap 是否为空 size() 计算 hashMap 中键/值对的数量 put() 将键/值对添加到 hashMap 中 putAll() 将所有键/值对添加到 hashMap 中 putIfAbsent() 如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。 remove() 删除 hashMap 中指定键 key 的映射关系 containsKey() 检查 hashMap 中是否存在指定的 key 对应的映射关系。 containsValue() 检查 hashMap 中是否存在指定的 value 对应的映射关系。 replace() 替换 hashMap 中是指定的 key 对应的 value。 replaceAll() 将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。 get() 获取指定 key 对应对 value getOrDefault() 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 forEach() 对 hashMap 中的每个映射执行指定的操作。 entrySet() 返回 hashMap 中所有映射项的集合集合视图。 keySet() 返回 hashMap 中所有 key 组成的集合视图。 values() 返回 hashMap 中存在的所有 value 值。 merge() 添加键值对到 hashMap 中 compute() 对 hashMap 中指定 key 的值进行重新计算 computeIfAbsent() 对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中 computeIfPresent() 对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。 ","date":"2021-01-13","objectID":"/java%E9%9B%86%E5%90%88/:0:2","tags":["Java"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["学习笔记"],"content":"API ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Vector Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的： Vector 是同步访问的。 Vector 包含了许多传统的方法，这些方法不属于集合框架。 Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 Vector 类支持 4 种构造方法。 第一种构造方法创建一个默认的向量，默认大小为 10： Vector() 第二种构造方法创建指定大小的向量。 Vector(int size) 第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。 Vector(int size,int incr) 第四种构造方法创建一个包含集合 c 元素的向量： Vector(Collection c) 序号 方法描述 1 void add(int index, Object element) 在此向量的指定位置插入指定的元素。 2 boolean add(Object o) 将指定元素添加到此向量的末尾。 3 void clear() 从此向量中移除所有元素。 4 boolean contains(Object elem) 如果此向量包含指定的元素，则返回 true。 5 Object get(int index) 返回向量中指定位置的元素。 6 int indexOf(Object elem) 返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。 7 boolean isEmpty() 测试此向量是否不包含组件。 8 int size() 返回此向量中的组件数。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:1","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。 堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。 Stack() 除了由Vector定义的所有方法，自己也定义了一些方法： 序号 方法描述 1 boolean empty() 测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:2","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"ArrayList ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。 ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下： import java.util.ArrayList; // 引入 ArrayList 类 ArrayList\u003cE\u003e objectName =new ArrayList\u003c\u003e();　// 初始化 E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。 objectName: 对象名。 ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 Java ArrayList 常用方法列表如下： 方法 描述 add() 将元素插入到指定位置的 arraylist 中 addAll() 添加集合中的所有元素到 arraylist 中 clear() 删除 arraylist 中的所有元素 clone() 复制一份 arraylist contains() 判断元素是否在 arraylist get() 通过索引值获取 arraylist 中的元素 indexOf() 返回 arraylist 中元素的索引值 removeAll() 删除存在于指定集合中的 arraylist 里的所有元素 remove() 删除 arraylist 里的单个元素 size() 返回 arraylist 里元素数量 isEmpty() 判断 arraylist 是否为空 subList() 截取部分 arraylist 的元素 set() 替换 arraylist 中指定索引的元素 sort() 对 arraylist 元素进行排序 toArray() 将 arraylist 转换为数组 toString() 将 arraylist 转换为字符串 ensureCapacity() 设置指定容量大小的 arraylist lastIndexOf() 返回指定元素在 arraylist 中最后一次出现的位置 retainAll() 保留 arraylist 中在指定集合中也存在的那些元素 containsAll() 查看 arraylist 是否包含指定集合中的所有元素 trimToSize() 将 arraylist 中的容量调整为数组中的元素个数 removeRange() 删除 arraylist 中指定索引之间存在的元素 replaceAll() 将给定的操作内容替换掉数组中每一个元素 removeIf() 删除所有满足特定条件的 arraylist 元素 forEach() 遍历 arraylist 中每一个元素并执行特定操作 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:3","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"LinkedList 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。 链表可分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。 与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。 以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 LinkedList 继承了 AbstractSequentialList 类。 LinkedList 实现了 Queue 接口，可作为队列使用。 LinkedList 实现了 List 接口，可进行列表的相关操作。 LinkedList 实现了 Deque 接口，可作为队列使用。 LinkedList 实现了 Cloneable 接口，可实现克隆。 LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:4","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Queue Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构 Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。 ​ add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 remove、element、offer 、poll、peek 其实是属于Queue接口。 ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:5","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["学习笔记"],"content":"Comparator自定义排序 Comparator接口可以实现自定义排序，实现Comparator接口时，要重写compare方法： int compare(Object o1, Object o2) 返回一个基本类型的整型 如果要按照升序排序,则o1 小于o2，返回-1（负数），相等返回0，01大于02返回1（正数） 如果要按照降序排序,则o1 小于o2，返回1（正数），相等返回0，01大于02返回-1（负数） list.sort(new Comparator\u003cPerson\u003e() { int flag=0; @Override public int compare(Person o1, Person o2) { int a=o1.getSex().compareTo(o2.getSex()); if(a!=0\u0026\u0026a\u003e0){ return -1; } else if(o1.getSex().equals(o2.getSex())){ if(o1.getAge()\u003co2.getAge()){ return -1; } else if(o1.getAge()==o2.getAge()){ if(o1.getWeigth()\u003co2.getWeigth()){ return -1; } else if(o1.getWeigth()==o2.getWeigth()){ if(o1.getHeight()\u003eo2.getHeight()){ return -1; } else if(o1.getHeight()==o2.getHeight()){ if(o1.getName().length()\u003co2.getName().length()){ return -1; } } } } } return 1; } }); ","date":"2021-01-13","objectID":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:6","tags":["Java"],"title":"Java数据结构","uri":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["个人网站"],"content":"安装Hugo 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe） Mac下直接使用 Homebrew 安装： brew install hugo ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:1","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录： $ cd /path/to/site 站点目录结构： ▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:2","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"创建文章 创建一个 about 页面： $ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下： +++ date = \"2015-10-25T08:36:54-07:00\" draft = true title = \"about\" +++ 正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。 $ hugo new post/first.md ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:3","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"安装皮肤 到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 Hyde 皮肤不错，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来： # 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:4","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"运行Hugo 在你的站点根目录执行 Hugo 命令进行调试： $ hugo server --theme=hyde --buildDrafts 若在config.toml设置了theme和buildDrafts： $ hugo server 浏览器里打开： http://localhost:1313 ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:5","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io（coderzh替换为你的github用户名）。 在站点根目录执行 Hugo 命令生成最终页面： $ hugo --theme=hyde --baseUrl=\"http://coderzh.github.io/\" 或者 $ hugo （注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成。） 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。 浏览器里访问：http://coderzh.github.io/ ","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:6","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"其他相关 关于文章内容 它使您可以直接包含内容的元数据。Hugo支持几种不同的格式，每种格式都有自己的识别令牌。 支持的格式： TOML，以“+++”标识。 YAML，由“---”标识。 JSON，一个单独的JSON对象，由'{'和'}'包围，每行各自。 YAML Example ---title:\"spf13-vim 3.0 release and new website\"description:\"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\"tags:[\".vimrc\",\"plugins\",\"spf13-vim\",\"vim\"]lastmod:2015-12-23date:\"2012-04-06\"categories:- \"Development\"- \"VIM\"slug:\"spf13-vim-3-0-release-and-new-website\"---ContentofthefilegoesHere Required variables title The title for the content description The description for the content date The date the content will be sorted by taxonomies These will use the field name of the plural form of the index (see tags and categories above) Optional variables aliases An array of one or more aliases (e.g. old published path of a renamed content) that would be created to redirect to this content. See Aliases for details. draft If true, the content will not be rendered unless hugo is called with --buildDrafts publishdate If in the future, content will not be rendered unless hugo is called with --buildFuture type The type of the content (will be derived from the directory automatically if unset) isCJKLanguage If true, explicitly treat the content as CJKLanguage (.Summary and .WordCount can work properly in CJKLanguage) weight Used for sorting markup (Experimental) Specify \"rst\" for reStructuredText (requires rst2html) or \"md\" (default) for Markdown slug The token to appear in the tail of the URL, or url The full path to the content from the web root. If neither slug or url is present, the filename will be used. 关于配置 通常的使用情况下，一个网站并不需要一个配置文件，因为它的目录结构和模板就提供了主要的配置。 Hugo 需要在源目录查找一个 config.toml 的配置文件。如果这个文件不存在，将会查找 config.yaml，然后是 config.json 。 这个配置文件是一个整站的配置。它给 Hugo 提供了如何构建站点的方式，比如全局的参数和菜单。 配置变量 下面是 Hugo 定义好的变量列表，以及他们的默认值，你可以设置他们： --- archetypedir: \"archetype\" # hostname (and path) to the root, e.g. http://spf13.com/ baseURL: \"\" # include content marked as draft buildDrafts: false # include content with publishdate in the future buildFuture: false # enable this to make all relative URLs relative to content root. Note that this does not affect absolute URLs. relativeURLs: false canonifyURLs: false # config file (default is path/config.yaml|json|toml) config: \"config.toml\" contentdir: \"content\" dataDir: \"data\" defaultExtension: \"html\" defaultLayout: \"post\" disableLiveReload: false # Do not build RSS files disableRSS: false # Do not build Sitemap file disableSitemap: false # edit new content with this editor, if provided editor: \"\" footnoteAnchorPrefix: \"\" footnoteReturnLinkContents: \"\" # google analytics tracking id googleAnalytics: \"\" languageCode: \"\" layoutdir: \"layouts\" # Enable Logging log: false # Log File path (if set, logging enabled automatically) logFile: \"\" # \"yaml\", \"toml\", \"json\" metaDataFormat: \"toml\" newContentEditor: \"\" # Don't sync modification time of files noTimes: false paginate: 10 paginatePath: \"page\" permalinks: # Pluralize titles in lists using inflect pluralizeListTitles: true # Preserve special characters in taxonomy names (\"Gérard Depardieu\" vs \"Gerard Depardieu\") preserveTaxonomyNames: false # filesystem path to write files to publishdir: \"public\" # color-codes for highlighting derived from this style pygmentsStyle: \"monokai\" # true: use pygments-css or false: color-codes directly pygmentsUseClasses: false # default sitemap configuration map sitemap: # filesystem path to read files relative from source: \"\" staticdir: \"static\" # display memory and timing of different steps of the program stepAnalysis: false # theme to use (located in /doc/themes/THEMENAME/) theme: \"\" title: \"\" # if true, use /filename.html instead of /filename/ uglyURLs: false # Do not make the url/path to lowercase disablePathToLower: false # if true, auto-detect Chinese/Japanese/Korean Languages in the content. (.Summary and .WordCount can work properly in CJKLanguage) hasCJKLanguage false # verbose output verbose: false # verbose logging verboseLog: false # watch filesystem for chan","date":"2020-10-15","objectID":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/:0:7","tags":["Blog"],"title":"Hugo个人静态网页生成","uri":"/hugo%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/"},{"categories":["个人网站"],"content":"GitHub Pages GitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub加Vercel。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:1","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第一步：注册登录Vercel 我想大家应该都有GitHub账号吧，这里就不多说了。 点击Vercel官网,并使用GitHub登录。 注意⚠️：GitHub账号不要使用QQ邮箱作为主邮箱。如果已经用QQ邮箱注册了GitHub，可以到Setting -\u003e Emails里修改自己的主邮箱。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:2","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第二步：导入仓库 它会让你选择一种登录Vercel的方法，支持使用GitHub，GitLab和Bitbucket登录，这里我们选GitHub，后面就是无脑Next的步骤。 顺利的话稍等片刻就会弹出部署成功的页面，还有浮夸的撒花。 部署完成之后可以点击visit进入网页看看效果。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:3","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["个人网站"],"content":"第三步：配置域名 1.点击view Domains进行绑定自己的域名或者点击Settings👉Domains👉输入自己的域名 2.输入自己的域名，然后点Add，它会弹出来一些需要做的配置，接下来需要去我们的域名提供商那里根据Vercel给出的要求进行配置。需要修改的有：Name Servers以及域名解析 最后等待等这两个改动都生效之后就可以用我们自己的域名访问刚刚建立的网站啦~ 以后想要修改网站的话，只需要将改动push到GitHub上，vercel会自动把改动同步过来，完全不用管，超省心。 在一级域名配置好之后，也可以直接在vercel中使用二级域名，无需进行额外设置。 ","date":"2020-10-14","objectID":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/:0:4","tags":["Blog"],"title":"搭建个人网站:GitHub加Vercel","uri":"/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99github%E5%8A%A0vercel/"},{"categories":["学习笔记"],"content":"一、引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.thymeleaf.extras\u003c/groupId\u003e \u003cartifactId\u003ethymeleaf-extras-springsecurity4\u003c/artifactId\u003e \u003cversion\u003e3.0.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:1","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"二、配置WebSecurityConfigurerAdapter 使用内存用户储存且认证 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests()//表示下面是认证的配置 .antMatchers(\"/login\").permitAll() .antMatchers(\"/login/form\").permitAll() .antMatchers(\"/css/**\").permitAll() .antMatchers(\"/js/**\").permitAll() .anyRequest()//任何请求 .authenticated();//都需要身份认证 http.formLogin()//表单认证 .loginPage(\"/login\")//使用本人制作的登录界面 .usernameParameter(\"user\")//username更改 .loginProcessingUrl(\"/login/form\")//表单提交的api .defaultSuccessUrl(\"/\")//登录成功跳转页面 .failureUrl(\"/login/error\").permitAll();//登录错误跳转界面 http.logout().logoutSuccessUrl(\"/login\");//登出 http.csrf().disable();//防止跨站攻击 } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication()//使用内存用户储存 //配置了一个user用户和一个admin用户 .withUser(\"user\").password(\"password\").roles(\"USER\").and() .withUser(\"admin\").password(\"password\").roles(\"USER\", \"ADMIN\"); } } ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:2","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"三、由数据库认证登录 在MySQL中创建用户表 CREATE TABLE `admin` ( `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `id` int(11) NOT NULL AUTO_INCREMENT, `role` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO `admin` VALUES ('admin', '123', 1, 'admin'); entity层创建实体 @Data //使用lombok,简化get,set public class UserInfo { private Integer id; private String username; private String password; private String role; } dao层创建数据存取对象 @Mapper//mapper.xml分离 @Repository public interface UserInfoDao { UserInfo getUserInfoByUsername(String username); } 创建dao对应的mapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"cn.llssit.ls.dao.UserInfoDao\"\u003e \u003cselect id=\"getUserInfoByUsername\" resultType=\"UserInfo\"\u003e select * from admin where username = #{username} \u003c/select\u003e \u003c/mapper\u003e service层 interface public interface UserInfoSevice { UserInfo getUserInfoByUsername(String username); } impl @Service public class UserInfoServiceImpl implements UserInfoSevice { @Autowired private UserInfoDao userInfoDao; @Override public UserInfo getUserInfoByUsername(String username) { return userInfoDao.getUserInfoByUsername(username); } } controller层或者其他运用 springsecurity数据库认证 首先需要重写接口loadUserByUsername @Component public class MyUserDetailService implements UserDetailsService { @Autowired private UserInfoSevice userInfoService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { // 通过用户名从数据库获取用户信息 UserInfo userInfo = userInfoService.getUserInfoByUsername(s); if (userInfo == null) { throw new UsernameNotFoundException(\"用户不存在\"); } // 得到用户角色 String role = userInfo.getRole(); // 角色集合 List\u003cGrantedAuthority\u003e authorities = new ArrayList\u003c\u003e(); // 角色必须以`ROLE_`开头，数据库中没有，则在这里加 authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role)); return new User( userInfo.getUsername(), // 因为数据库是明文，所以这里需加密密码 new BCryptPasswordEncoder().encode(userInfo.getPassword()), authorities ); } } 然后创建Security的配置类WebSecurityConfig继承WebSecurityConfigurerAdapter，并重写configure(auth)方法 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private MyUserDetailService userDatailService; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/login\").permitAll() .antMatchers(\"/login/form\").permitAll() .antMatchers(\"/css/**\").permitAll() .antMatchers(\"/js/**\").permitAll() .anyRequest() .authenticated(); http.formLogin() .loginPage(\"/login\") .usernameParameter(\"user\") .loginProcessingUrl(\"/login/form\") .defaultSuccessUrl(\"/\") .failureUrl(\"/login/error\").permitAll(); http.logout().logoutSuccessUrl(\"/login\"); http.csrf().disable(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth // 从数据库读取的用户进行身份认证 .userDetailsService(userDatailService) .passwordEncoder(new BCryptPasswordEncoder()); } } 角色访问 @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启方法级安全验证 修改Controller.java类，增加方法的访问权限@PreAuthorize(\"hasAnyRole('admin')\") ","date":"2020-10-12","objectID":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/:0:3","tags":["SpringBoot"],"title":"浅学SpringSecurity+SpringMybatis","uri":"/%E6%B5%85%E5%AD%A6springsecurity-springmybatis/"},{"categories":["学习笔记"],"content":"Java集合框架 导入包 import java.util.*; ArrayList 一、定义一个ArrayList //默认创建一个ArrayList集合 List\u003cString\u003e list = new ArrayList\u003c\u003e(); //创建一个初始化长度为100的ArrayList集合 List\u003cString\u003e initlist = new ArrayList\u003c\u003e(100); //将其他类型的集合转为ArrayList List\u003cString\u003e setList = new ArrayList\u003c\u003e(new HashSet()); 二、ArrayList常用方法 add(E element) set(int index, E element) 因为ArrayList底层是由数组实现的，set实现非常简单，调用 set(4, \"4\") 通过传入的数字下标找到对应的位置，替换其中的元素，前提也需要首先判断传入的数组下标是否越界。 get(int index) remove(int index) remove(Object o) 其他方法 size() : 获取集合长度，通过定义在ArrayList中的私有变量size得到 isEmpty()：是否为空，通过定义在ArrayList中的私有变量size得到 contains(Object o)：是否包含某个元素，通过遍历底层数组elementData，通过equals或==进行判断 clear()：集合清空，通过遍历底层数组elementData，设置为null ArrayList的遍历 List\u003cString\u003e list=new ArrayList\u003cString\u003e(); list.add(\"Hello\"); list.add(\"World\"); list.add(\"HAHAHAHA\"); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) { //也可以改写 for(int i=0;i\u003clist.size();i++) 这种形式 System.out.println(str); } //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i\u003cstrArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 { System.out.println(strArray[i]); } //第三种遍历 使用迭代器进行相关遍历 Iterator\u003cString\u003e ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 { System.out.println(ite.next()); } HashMap 一、定义一个HashMap Map\u003cString, String\u003e map = new HashMap\u003c\u003e(); 二、HashMap常用方法 public V put(K key, V value) :插入键值对数据 public V get(Object key) :根据键值获取键值对值数据 public int size() :获取Map中键值对的个数 public boolean containsKey(Object key) :判断Map集合中是否包含键为key的键值对 boolean containsValue(Object value) :判断Map集合中是否包含值为value的键值对 public boolean isEmpty() :判断Map集合中是否没有任何键值对 public V remove(Object key) :根据键值删除Map中键值对 public void clear() :清空Map集合中所有的键值对 HashMap的遍历 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); //第一种：普遍使用，二次取值 System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) { System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); } //第二种 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator\u003cMap.Entry\u003cString, String\u003e\u003e it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry\u003cString, String\u003e entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry\u003cString, String\u003e entry : map.entrySet()) { System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第四种 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) { System.out.println(\"value= \" + v); } ","date":"2020-10-12","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"Java多线程 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 一个线程的生命周期 线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态： 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态： 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态： 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态： 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态： 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 Thread 方法 序号 方法描述 1 **public void start()**使该线程开始执行；==Java== 虚拟机调用该线程的 run 方法。 2 **public void run()**如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 **public final void setName(String name)**改变线程名称，使之与参数 name 相同。 4 **public final void setPriority(int priority)** 更改线程的优先级。 5 **public final void setDaemon(boolean on)**将该线程标记为守护线程或用户线程。 6 **public final void join(long millisec)**等待该线程终止的时间最长为 millis 毫秒。 7 **public void interrupt()**中断线程。 8 **public final boolean isAlive()**测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 **public static void yield()**暂停当前正在执行的线程对象，并执行其他线程。 2 **public static void sleep(long millisec)**在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 **public static boolean holdsLock(Object x)**当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 **public static Thread currentThread()**返回对当前正在执行的线程对象的引用。 5 **public static void dumpStack()**将当前线程的堆栈跟踪打印至标准错误流。 创建一个线程 Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现Runnable 接口来创建线程 创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： public void run() 你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是我们经常使用的： Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 void start(); 下面是一个创建线程并开始让它执行的实例： class RunnableDemo implements Runnable { private Thread t; private String threadName; RunnableDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i \u003e 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } } } public class TestThread { public static void main(String args[]) { RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); } } 通过继承Thread来创建线程 创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 class ThreadDemo extends Thread { private Thread t; private String threadName; ThreadDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i \u003e 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + ","date":"2020-10-12","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"一、写前准备 在atom文本编译器中自带着markdown的编写与浏览功能。 浏览使用快捷键ctl+shift+m就可以打开markdown预览。 简书中在设置-\u003e默认编辑器-\u003emarkdown编译，就可以设置markdown。 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:1:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"二、标题 在想要设置为标题的文字前面加#来表示标题 一个#号是以及标题，两个#是二级标题，最多有六级标题 标准语法需要在#后加空格才能表示 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:2:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"三、字体 加粗 在要加粗的文字左右分别用两个*标注 斜体 在要倾斜的文字左右分别用一个*标注 斜体加粗 在要倾斜和加粗的文字左右分别用三个*标注 删除线 在要加删除线的文字左右分别用两个～标注 例如： **加粗字体** *斜体字体* ***斜体加粗字体*** ~~删除字体~~ 效果： 加粗字体，斜体字体，斜体加粗字体，删除字体 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:3:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"四、引用 在引用文字前加\u003e。引用可以嵌套，如一个\u003e、两个\u003e等等 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:4:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"五、\u0008分割线 三个或三个以上的-或者*\u0008\u0008 例： --- *** \u0008效果: ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:5:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"六、\u0008图片 使用方法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:6:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"七、超链接 使用方法： [超链接名](超链接地址 \"超链接title\") title可加可不加 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 \u003ca href=\"超链接地址\" target=\"_blank\"\u003e超链接名\u003c/a\u003e 示例 \u003ca href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\"\u003e简书\u003c/a\u003e ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:7:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"八、列表 无序列表 使用方法：无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表 使用方法：数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 列表嵌套 使用方法：上一级和下一级之间敲三个空格 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:8:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"九、表格 使用方法： |表头|表头|表头| |-|:-:|-:| |内容|内容|内容| |内容|内容|内容| 第二行分割表头和内容。 -有一个就行 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:9:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十、代码 使用方法： 单行代码：代码之间分别用一个反引号包起来 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 代码\u0008高亮：在第一行反引号后面输入代码块所使用的语言 代码高亮演示： `c #include \"stdio.h\" int main(){ printf(\"hello world\\n\"); return 0; } ` #include \"stdio.h\" int main(){ printf(\"hello world\\n\"); return 0; } ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:10:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十一、流程图 使用方法： st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:11:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十二、数学表达式 用反引号将数学表达式封装,并在第三个号后标注math代表数学公式. E = mc^2 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:12:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"十三、待办事项 在待办的事项文本或者清单文本前加上- 、- [x]即可 - [ ] 表示未完成，- [x] 表示已完成。 注：键入字符与字符之间都要保留一个字符的空格。 \u0008效果 分析需求 研发 测试 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:13:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"结语 Markdown换行方法： 在本行最后\u0008敲两个空格即可 每行间空一行即可 Mac上反引号方法： 在英文状态下按住option键+数字\u00081左边的键 本文章为个人学习笔记，转载了多人的博客，如有雷同请见谅。 ","date":"2020-10-12","objectID":"/markdown%E7%AC%94%E8%AE%B0/:14:0","tags":["Markdown"],"title":"Markdown笔记","uri":"/markdown%E7%AC%94%E8%AE%B0/"}]